#+STARTUP: lognotedone

* Workflow [2015-01-19 Mon]
** Commit conventions
1. Name branch I am working in.
2. Be explicit about what has been done.
3. Mark if a "project" is finished.

** Working with tremolo
*** Konventionen für Tremolo Code (Kommentare, Coding Guidlines)
- Zum Einrücken immer nur 2 Leerzeichen verwenden. (Habe das bereits in Emacs geändert.)

*** Tremolo und tremologui aktualisieren

Nachdem eine neue Version des Tremolo-Ordners gepullt wurde, kann Tremolo wie folgt aktualisiert werden:
: cd ~/tremolo/build
: make && make install

Das selbe gilt für Tremologui.
: cd ~/tremologui/build
: make && make install

In seltenen Fällen muss evtl. auch die CMake-Datei neu erzeugt werden: Dafür im build-Ordner:
: ccmake ..

Momentan sind die Pfadvariablen so eingestellt, dass die binaries in /home/huber/bin kopiert werden. Das kann man im ccmake Menu unter install_prefix ändern.

*** Neue source und header Dateien in Tremolo einbinden
Dateien zunächst in [[file:~/tremolo/src]] einfügen, dann die Source-Datei in [[file:~/tremolo/CMakeLists.txt]] hinzufügen.

*** Tremolo testen
Für self-tests von Tremolo kann das Programm runpybbt.py in [[~/tremolo/build/tests/]] verwendet werden.
*** Visualisieren von Tremolodaten
Dazu kann das Programm VMD verwendet werden: VMD visualisiert .xyz und .pdb Files:
: vmd *.xyz
Die graphische Anpassung kann in VMD unter Graphics->Representation angepasst werden.

** Gnuplot Befehle

Einen Ueberblick zu nuetzlichen Gnuplot Befehlen kann auf der folgenden Seite gefunden werden: http://people.duke.edu/~hpgavin/gnuplot.html

1. Um ein Data-file (zum Beispiel =*.epot*=) mit Gnuplot zu plotten, verwendet man: \\
   : gnuplot> plot "./argon.epot" using 1:2
   Hierbei wird die zweite Spalte gegen die erste Spalte aufgetragen.
2. Dies kann auch mit mehreren Files gleichzeitig getan werden: \\
   : gnuplot> plot "./argon.etot" using 1:2, "./argon.ekin" using 1:2, "./argon.epot" using 1:2
3. Um den Achsenabschnitt zu veraendern, verwendet man: \\
   : gnuplot> plot "./argon.epot" using 1:2; set yrange [-0.1: 2]
4. Den urspruenglichen Achsenabschnitt kann man wie folgt wieder herstellen: \\
   : gnuplot> plot "./argon.epot" using 1:2; set autoscale
5. Mit \\
   : gnuplot> replot
   kann der Plot aktualisiert werden.
6. Eine Uebersicht von =set= Befehlen:
   Create a title:
   : set title "Force-Deflection Data"
   Put a label on the x-axis:
   : set xlabel "Deflection (meters)"
   Put a label on the y-axis:
   : set ylabel "Force (kN)"
   Change the x-axis range:
   : set xrange [0.001:0.005]
   Change the y-axis range:
   : set yrange [20:500]
   Have Gnuplot determine ranges:
   : set autoscale
   Move the key:
   : set key 0.01,100
   Delete the key:
   : unset key
   Put a label on the plot:
   : set label "yield point" at 0.003, 260
   Remove all labels:
   : unset label
   Plot using log-axes:
   : set logscale
   Plot using log-axes on y-axis:
   : unset logscale; set logscale y
   Change the tic-marks:
   : set xtics (0.002,0.004,0.006,0.008)
   Return to the default tics:
   : unset xtics; set xtics auto
   Set output:
   : set output 'introduction.png'

** Grep Befehle

http://www.panix.com/~elflord/unix/grep.html

** Git Befehle

*** Branches
- Create a new branch:
  : git branch <name_of_new_branch>
- Create a new branch by pulling from a remote branch:
  : git checkout -b <name_of_new_branch> origin/<name_of_branch>
- Delete a local branch:
  : git branch -d <name_of_branch>
- Naming convention: use well defined tokes like
  : feature
  : bugfix
  : test
  followed by a slash '/' and a describing name, e.g.:
  : feature/potentials

*** Diff
- Show differences between <branch1> and <branch2>
  : git diff <branch1>..<branch2>

*** Manipulate changes.
- Remove untracked files:
  : git clean -f -d

*** Add and remove changes.
- Remove deleted files from stack:
  : git add -u .

*** Remote repositories
- Add remote repository with name /origin/ (e.g. https://pascalkimhuber@bitbucket.org/pascalkimhuber/stacked.git)
  : git remote add origin <address of remote>
- Push a local repository to a remote repository with name /origin/ for the first time
  : git push -u origin --all

*** Merging branches
- Merge <branch1> into <branch2>
  : git checkout <branch2>
  : git merge <branch1>
** Find Befehle

- Find all files with names containing =<pattern>= (wildcards have to be used with a preceeding backslash!):
  : find -name <pattern>
  or e.g.
  : find -name <pattern>\*

** Doxygen Befehle

- [[http://www.stack.nl/~dimitri/doxygen/manual/commands.html#cmdc][List of special commands]]

** GDB Befehle

*** Within GDB
Start the TUI (see source code and output)
: CTRL-x a
or just
: win
** CTags in Emacs
In order to create the tags I ran the following command:
: find . -type f -iname "*.[xhS]" |xargs etags -a

In emacs ctags can be handled with the following commands:
- =M-. <RET>= :: Jump to the tag underneath the cursor.
- =M-. <tag> <RET>= :: Search for a particular tag.
- =C-u M-.= :: Find the next definition for the last tag.
- =M-*= :: Pop back where you previously invoked "M-.".



* Emacs [2015-01-19 Mon]
** TODO Rewrite Arbeitszeiten section


* Todos [2015-01-19 Mon]

** TODO <2015-03-27 Fri> Fix SystemOfUnits bug in tremolo and tremologui (Redmine Bug 420)
   - Note taken on [2015-03-27 Fri 11:28] \\
     Some notes:

     1. Bug
     The system of units has been specified in two files:
     - in previous versions of tremolo :: in =.tremolo= file: =global: systemofunits=
     - in current version of tremolo :: in =.potentials= file: =unitsystem: systemofunits=
     This can lead to conflicts if the system of units is set in both files at once. This shall be fixed.
     The desired behaviour is:
     1. If the system of units is set only in the =tremolo=-file: output warning (only if this is possible!)
     2. If the system of units is set only in the =potentials=-file: output warning
     3. If the system of units is set in both files: compare the values and abort if not equal

     2. Bug
     If no system of units could be found after parsing, the simulation should abort!

     3. Bug (detail)
     In StoreSystemOfUnits() check also return value 1 and 2 of StoreSystemOfUnits_WORK().

     Relevant files for tremologui
     project_data.cpp: getValuesFromFile() gets systemofunits from tremolo file
     parser for potential files must be added.

     Relevant files for tremolo
     parse.c : ParsePotentialFiles for potentials file
     init.c: storeGlobalParameters for tremolo file
*** <2015-04-20 Mon> Description of system-of-units input
**** =tremolo=-file
The system of units is set in the =tremolo=-file with
: global: systemofunits=$SYSTEM_OF_UNITS
The possible choices for =$SYSTEM_OF_UNITS= are:
- =kcalpermole=
- =evolt=
- =si=
- =custom=
If the choice =custom= is selected, then the units must be specified separately!!
#+BEGIN_SRC
custom: lengthunit = { angstrom , nm, m};
custom: lengthscalingfactor = 1.0;
custom: timeunit = {fs, ps, s};
custom: timescalingfactor = 1.0;
custom: massunit = {u, kg};
custom: massscalingfactor = 1.0;
custom: currentunit = {"e/s", A};
custom: currentunitscalingfactor = 1.0;
custom: temperatureunit = {K};
custom: temperaturescalingfactor = 1.0;
#+END_SRC
**** =potentials=-file
The system of units is set in the =potentials=-file with
: unitsystem: systemofunits=$SYSTEM_OF_UNITS
All other options are the same as in the =tremolo=-file.
I do not know yet what the format for the custom settings is supposed to be.
*** Code description in tremolo
Note that the tremolo file is parsed before the potentials file
**** System of units parsing in =potentials= file
The parsing routines for the =unitsystem= keyword can be all found in =parse.c=:
- =ParsePotentialFiles()= :: Register and execute the function =StoreSystemOfUnits()=
- =StoreSystemOfUnits()= :: Here the parsed identifier-word =systemofunits= is evaluated using the return values from the function =StoreSystemOfUnits_WORK()=
- =StoreSystemOfUnits_WORK()= :: This functions checks which system of unit is selected. Then it compares it with the already present system of units (if it exists) and issues error codes if conflicting types were found
**** System of units parsing in =tremolo= file
In order to parse the unit system in the tremolo file, essentially the same files are used:
- =StoreGlobalParameters()= :: Prints out a warning that unit systems in =tremolo=-files are deprecated and calls =StoreSystemOfUnits()= (see above)
*** DONE Set-up a test case
    CLOSED: [2015-04-20 Mon 14:47]
    - CLOSING NOTE [2015-04-20 Mon 14:47] \\
      Done in [[file:~/Documents/Work/sandbox/test_systemofunits/test.tremolo]].
*** DONE Do some initial tests and document the behaviour
    CLOSED: [2015-04-20 Mon 18:09]
    - CLOSING NOTE [2015-04-20 Mon 18:09] \\
      Did all tests.
Some test results:
1. If the system of units is set in the tremolo file using the keyword =global= a warning is issued:
   =WARNING: Definition of unit system in the tremolo file is deprecated and may not be supported in future versions of tremolo.
   Define the unit system in the .potentials file instead.=
   This does not happen if the system of units is set with the keyword =unitsystem=
   The reason is that in =ReadMainParameterFile()= [init.c] the functions =StoreGlobalParameters()= *and* =StoreSystemOfUnits()= are registered for parsing.
2. Custom system of units are not supported. The only thing that happens is, that the function =IgnoreCustomParameters()= is called.
   The function does nothing.
3. If different system of units are used the simulation aborts with a short error message.
4. If no system of units is specified, the system of units is set to =NoUnits= and the simulation runs (!). -> Bad behaviour.
5. If the same system of units are used in both files, the simulation runs, but issues the above warning about deprecated definition.
6. If the system of units is specified only in the potentials file, the simulation runs. No warning is issued.
*** DONE <2015-04-20 Mon> Ask Christian:
    CLOSED: [2015-04-23 Thu 09:37]
    - CLOSING NOTE [2015-04-23 Thu 09:37] \\
      Done. Answers can be found in an email.
- [X] What is the format for the system of units settings in =potentials=-file?
  =custom: ...=
- [X] From which branches should I checkout?
  /testing/
- [X] Custom system of units are not supported at all!
  /This is ok like this./
- [X] Simulation runs even if no system of units is specified.
  /In this case the simulation should abort./
- [X] In the tremolo file both keywords =global= and =unitsystem= can be specified. Only if =global= is used a warning is issued!
  /It is not clear yet, what the default behaviour should be./
*** DONE <2015-04-23 Thu> Desired behaviour for tremolo
    CLOSED: [2015-04-23 Thu 09:50]
    - CLOSING NOTE [2015-04-23 Thu 09:50] \\
      Done.
1. If unit systems in tremolo-file and potentials-file coincide  --> do nothing
2. If unit systems in tremolo-file and potentials-file differ    --> abort simulation
3. If unit system is set only in one of the files                --> Issue a warning
4. If no unit system is specified                                --> abort simulation with warning
5. If unknown system of units is specified                       --> abort simulation with warning
*** DONE Abort simulation/issue warning if no system of units is defined
    CLOSED: [2015-04-23 Thu 15:01]
    - CLOSING NOTE [2015-04-23 Thu 15:01] \\
      Done.
For this the system of units have to be checked in separately in =ParsePotentialFiles()=.
The check is done in =ReadParameters()= (init.c)
*** DONE Issue warnings if no system of units was found in one of the files.
    CLOSED: [2015-04-23 Thu 15:01]
    - CLOSING NOTE [2015-04-23 Thu 15:01] \\
      Done.
If no system of units was found in the tremolo file a warning is issued in =ReadParameters()= (init.c).
I have no idea how to check if the potentials file was parsed.
*** DONE Questions for Christian:
    CLOSED: [2015-04-24 Fri 10:12]
    - CLOSING NOTE [2015-04-24 Fri 10:12] \\
      Done.
- In parse.h comments for =StoreSystemOfUnits()=: "Parsing in multiple files
  (potentials, *parameters*, tremolo (deprecated) )"
  What exactly is parsed in the parameters file?
- What formulation for warning message?
=Unable to perform consistency check with ...=
*** DONE Add Consistency flag to Problem struct
    CLOSED: [2015-04-24 Fri 11:18]
    - CLOSING NOTE [2015-04-24 Fri 11:18] \\
      Done.
The consistency flag =P->unitSystemConsistency= is set in =StoreSystemOfUnits()=.
The consistency check itself is also done in this function.
In =CheckAllPotentials()= a warning is issued if the consistency check could not be performed.
*** DONE Desired behaviour in tremologui w.r.t. the unit system
    CLOSED: [2015-04-24 Fri 12:18]
    - CLOSING NOTE [2015-04-24 Fri 12:18] \\
      Defined desired behaviour of the unit system handling in tremologui.
      I am not really sure if the values should be transferred to the
       potentials-file if they are only present in the tremolo-file.
- invalid system of units in one of the two files ::
     Display error message.
- different system of units or different custom values in the files ::
     Display error message.
- same system of units in both files ::
     Load correct values.
- system of units only in =tremolo=-file ::
     Display pop-up warning and ask if values should be transferred to =potentials=-file.
- system of units only in =potentials=-file ::
     Display pop-up warning and ask if values should be transferred to =tremolo=-file.
*** DONE Code description in tremologui
    CLOSED: [2015-04-26 Sun 14:57]
    - CLOSING NOTE [2015-04-26 Sun 14:57] \\
      Done. The description of =saveMainfile()= is still missing.
**** Some reminders
The main class for the tremologui application is =class TremoloGUI=.
This has as a member class =Project_Control* myProject= which
in turn has the member =Project_Data* mainProject= which is storing and
handling all data related to the current project.
In this class the loading of data files should be done (getValuesFromFile()).
**** Use of getValuesFromFile()
The function =getValuesFromFile()= parses the =.tremolo=-file of the project.
It is called whenever one of the following methods is executed:
- =createProject()=
  <-- =checkSavedStatusAndNewProject()= (slot)
- =openProject()=
  <-- =checkandLoad()=      <-- =Tremologui()= (constructor)
  <-- =checkSavedStatusAndOpenProject()= (slot)
- =loadclone=
  <-- =openProject()= (see above)
**** Use of Project_Data::saveMainfile()
The function writes the values to the tremolo-file.
The function is used in
- =Project_Control::createProject()=
- =Project_Control::validateProject()= which is used in =openProject()=
*** DONE <2015-04-27 Mon> Add warning messages to log in tremologui
    CLOSED: [2015-04-27 Mon 14:35]
    - CLOSING NOTE [2015-04-27 Mon 14:35] \\
      Done.
*** DONE <2015-04-27 Mon> Change handling of unit system during project creation
    CLOSED: [2015-04-30 Thu 00:11]
    - CLOSING NOTE [2015-04-30 Thu 00:11] \\
      Done
In this case some default values are set. These should be transferred to the potentials file.
*** DONE <2015-04-27 Mon> Change handling of unit system during potential loading
    CLOSED: [2015-04-30 Thu 00:11]
    - CLOSING NOTE [2015-04-30 Thu 00:11] \\
      Done.
In this case the user should get three different options:
1. Load potentials file even if the unit systems are different
2. Take over system of units to tremolo file
3. Abort loading.
*** DONE <2015-04-30 Thu> Adapt custom-settings.
    CLOSED: [2015-05-04 Mon 14:36]
    - CLOSING NOTE [2015-05-04 Mon 14:36] \\
      Done
This includes
- [ ] Load custom settings, if unit system is set to =custom=
- [ ] Compare custom settings, if unit system is set to =custom=
*** DONE Problems
    CLOSED: [2015-04-30 Thu 17:26]
    - CLOSING NOTE [2015-04-30 Thu 17:26] \\
      done
- [X] Potentials file is deleted -> warning issued when saving, but nothing happens.
  I had to reload the file to the Potentialparameter-TextEdit.
*** DONE <2015-04-27 Mon> Reread doc-comments in project_data.h
    CLOSED: [2015-04-30 Thu 17:28]
    - CLOSING NOTE [2015-04-30 Thu 17:28] \\
      Done
*** TODO <2015-04-20 Mon> Adapt Manual to changes
**** Description: Behaviour of tremologui with regard to the system of units. 
In the following the behaviour of tremologui with respect to changes in the 
project's system of units in described: 
***** Loading an existent project
This section describes the behaviour of tremologui when opening an existent 
project using the "Open Project" button: 
****** No system of units declared in the project to be loaded: 
If neither in the tremolo-file nor in the potentials-file any system of units is
present, tremologui aborts the load-process and displays an error message. 
****** System of units present in only one of the two files
In this case the user is asked if he/she would like to transfer the system of 
units also to the file in which it is missing. If he accepts the system of units
is transfered immediately to the other file and the project is loaded. If he 
declines, the project is loaded nevertheless. 
****** Different system of units
If the system of units in both files differ, then the load-process is aborted 
and an error message is displayed. 
****** Invalid system of units
If in one of the files an invalid descriptor for the system of units is set
(e.g. =global: systemofunits=iamstupid=) then tremologui aborts the load-process
and issues an error message. 
****** Consistent system of units 
If in both files the same system of units (and in the case of =custom= the same
parameters) are set, then the project is loaded without errors. 
***** Creating a new project
If a new project is created the system of units is set to =KCal per Mole= by 
default and the system of units is written to both files (tremolo-file and 
potentials-file) immediately. 
***** Changing the system of units and saving the current project
This section describes the behaviour of tremologui if the system of units of 
the currently loaded project is changed within tremologui and these changes are
then saved to the project.
****** Change system of units in "General parameters" tab 
If the user changes the system of units in the "General parameters" tab of 
tremologui and attempts to save the project afterwards, then tremologui issues 
a warning messages. In this message the user is asked if he/she would like to 
apply the system of units set in the *potentials*-file to the project. 
If he/she choses "Apply" the system of units is reset to the value set in the 
potentials-file. If he/she choses "Abort" the same message appears again (the 
reason for this is how the save-methods in tremologui are written...) and if 
the user choses "Abort" once again an error message appears indicating that the 
project was not saved. 
This means: if the user wants to change the system of units he/she has to do 
it in the "Generam parameters" tab *and* in the potentials file. 
****** Edit/change the potentials file 
If the system of units in the potentials-file is changed (either by manually 
editing the existent file or by loading a new file) and the user likes to 
save the changes afterwards, then tremologui issues the same message as above,
i.e. the user is asked if he/she would like to "Apply" the system of units in 
the potentials file to the whole project (in this case the system of units is 
transferred immediately to the tremolo-file) or if he/she would like to "Abort"
the save-process (in this case the behaviour is the same as described in the 
previous subsection). 
****** Saving if no system of units is set in the potentials-file
If no system of units is set in the potentials-file and the user attempts to 
save the current project, he/she is asked if tremologui should transfer the 
current system of units (as displayed in the "General parameters" tab) to the 
potentials file. (If he/she declines this question the question is displayed 
again - this is the same sort of bug as for the error message described in 
two preceding sections). 
***** General remarks
If the one of the two files (tremolo-file or potentials-file) contains a keyword
like =systemofunits= at some strange position in the file (e.g. as part of the 
file-path) the file will not be parsed. 
** DONE <2015-03-27 Fri> Adapt Manual for Hessian output
   CLOSED: [2015-04-17 Fri 19:24]
   - CLOSING NOTE [2015-04-17 Fri 19:24] \\
     Done.
Include
- output format
- only LJ
- add #TODO-Flag and refer to splines
** DONE <2015-03-27 Fri> Reread written code
   CLOSED: [2015-04-17 Fri 17:38] SCHEDULED: <2015-03-30 Mon>
   - CLOSING NOTE [2015-04-17 Fri 17:38] \\
     Done and checked.
     I checked some of the results after the merge too.
- Check for weird comments etc.
** DONE <2015-03-06 Fri> Merge <testing> into <hessians_pascal>
   CLOSED: [2015-04-17 Fri 12:35]
   - CLOSING NOTE [2015-04-17 Fri 12:35] \\
     Done and committed.
*** DONE Fix all errors <2015-04-11 Sat>
    CLOSED: [2015-04-17 Fri 12:29]
    - CLOSING NOTE [2015-04-17 Fri 12:29] \\
      Fixed all errors.
      The memory errors were related to the use of TrxGetParticle_hessianIndexj() which caused buggy access to the arrays.

** DONE <2015-03-19 Thu> Hessian output for parallel computation [6/6]
   CLOSED: [2015-03-27 Fri 11:23]
   - CLOSING NOTE [2015-03-27 Fri 11:23] \\
     Done.
*** DONE <2015-03-22 Sun> Replace OpenFileNoPost() by OpenFilesNoPost()
    CLOSED: [2015-03-22 Sun 15:05]
    - CLOSING NOTE [2015-03-22 Sun 15:05] \\
      Replacing the function results in having one .hessians file for each processor at each time step.
      The MergeOutput.py script has to be adapted.
*** DONE <2015-03-22 Sun> Adapt MergeOutput.py script
    CLOSED: [2015-03-22 Sun 17:31]
    - CLOSING NOTE [2015-03-22 Sun 17:31]
      Done.
*** DONE <2015-03-22 Sun> Test results for sequentiel and parallel Hessian computation computation
    CLOSED: [2015-03-25 Wed 15:34]
    - CLOSING NOTE [2015-03-25 Wed 15:34] \\
      Tests done. Wrote summary in hessians file: [[file:hessians/parallel_tests/summary.org]]
    - Note taken on [2015-03-23 Mon 15:13] \\
      Discussion with Christian. Do the following:
      - [X] In Code schauen
      - [X] Gebiet anpassen
      - [X] 2er über Gebietsgrenze
      - [X] 2er auf verschiedenen Gebieten
      - [X] 3er testen
      - [ ] 4er testen (komplett auf Master)
    - Note taken on [2015-03-22 Sun 17:34] \\
      Compare [[file:~/Documents/Work/sandbox/test_hessians/parallel2/test.tremolo]] and [[file:~/Documents/Work/sandbox/test_hessians/4particles/4particles_tetrahedron_r3/test.tremolo]]
*** DONE <2015-03-25 Wed> Check parallel Hessian computation
    CLOSED: [2015-03-26 Thu 15:46]
    - CLOSING NOTE [2015-03-26 Thu 15:46] \\
      Done. It turnend out that the not for all particles the interaction with ghost particles is computed.
      But some particles the force components are only computed for exactly one particle, ghost particle pair and then the calculate force is sent over to the other processors.
    - Note taken on [2015-03-25 Wed 15:35] \\
      The processor rank can be get with the =myrank= variable.
      When outputting, the ghost particles are still in place, such that I have to set the =IsSent()= function during output.
    - [X] Use printf-debugging: write out processor rank, which interaction is computed
    - [X] Check if Hessian result is written in both particles
    - [X] Print out Hash-Table during output.
*** DONE <2015-03-26 Thu> Change [[file:~/tremolo/util/MergeOutput.py][MergeOutput.py]] such that line with same coordinates are added
    CLOSED: [2015-03-26 Thu 19:30]
    - CLOSING NOTE [2015-03-26 Thu 19:30] \\
      Done.
*** DONE <2015-03-26 Thu> Test MergeOutput.py
    CLOSED: [2015-03-27 Fri 11:23]
    - CLOSING NOTE [2015-03-27 Fri 11:23] \\
      All tests were successful.
** DONE <2015-03-18 Wed> Finish hessian test log
   CLOSED: [2015-03-19 Thu 13:34]
   - CLOSING NOTE [2015-03-19 Thu 13:34] \\
     Done.
   - Note taken on [2015-03-18 Wed 17:47] \\
     Write Email to Christian.
*** DONE <2015-03-18 Wed> Plot for the Hessian test log 1.5.2
    CLOSED: [2015-03-19 Thu 13:13]
    - CLOSING NOTE [2015-03-19 Thu 13:13] \\
      Done using again a python script.
Plot the matrix entries (H_21)_12 vs (H_23)_12 and add this to the plot.
*** DONE <2015-03-19 Thu> Is H_21 = H_12?
    CLOSED: [2015-03-19 Thu 13:14]
    - CLOSING NOTE [2015-03-19 Thu 13:14] \\
      Done.
Yes, this true by the formula.
*** DONE <2015-03-18 Wed> Apply tar to hessian test files and give them to Christian
    CLOSED: [2015-03-19 Thu 13:34]
    - CLOSING NOTE [2015-03-19 Thu 13:34] \\
      Done.
** DONE <2015-01-19 Mon> Test Hessian computation in tremolo
   CLOSED: [2015-03-16 Mon 18:08]
   - CLOSING NOTE [2015-03-16 Mon 18:08] \\
     Done.
Log all tests for later reference.
*** DONE For two particles
    CLOSED: [2015-02-25 Wed 15:44]
    - CLOSING NOTE [2015-02-25 Wed 15:44] \\
      Finished tests for two particles simulation.
- [X] Test in all three coordinate directions for the following points: at \sigma, at the two points defining the valley, and at the tail, and zero-interaction
- [X] Test diagonal alignement of the coordinates for the same points
- [X] Test transition from interaction to zero-intraction (e.g. one particle with start velocity)
*** DONE For three partifcles
    CLOSED: [2015-03-14 Sat 14:53] SCHEDULED: <2015-03-13 Fri 17:00>
    - CLOSING NOTE [2015-03-14 Sat 14:53] \\
      Done.
- [X] Test in all three coordinate directions for the following points: at \sigma, at the two points defining the valley, and at the tail, an zero-interaction
- [X] Note matrix eigenvalues
- [X] Test collision
*** DONE For four particles
    CLOSED: [2015-03-13 Fri 11:40] SCHEDULED: <2015-03-13 Fri 10:00>
    - CLOSING NOTE [2015-03-13 Fri 11:40] \\
      Wrote short summary.
- [X] Tetrahedron, note matrix eigenvalues for r=1
- [X] Write down results
*** DONE Test parallel computation
    CLOSED: [2015-03-14 Sat 15:06] SCHEDULED: <2015-03-13 Fri 17:00>
    - CLOSING NOTE [2015-03-14 Sat 15:06] \\
      Further tests are necessary!
Tested parallel computation on the 2 particle collision simulation:
#+BEGIN_SRC sh
# ATOMDATA Id x=3 u=3 type
1	40.0    40.0    40.0    0.0	0.0	0.0	Argon
2	20.0    40.0    40.0   40.0	0.0	0.0	Argon
#+END_SRC
with 8 processors:
: mpirun -np 8 tremolo_mpi -p 2,2,2 test.tremolo
**** Issues:
- Some of the hessians-files are totally empty, in some only the header is displayed and in other only the body. But at least some values for the local Hessians are computed at all.
- A short comparison with the values of the serial computation shows that the computed values are identical.
*** DONE Reread test protocol
    CLOSED: [2015-03-16 Mon 17:51] SCHEDULED: <2015-03-16 Mon>
    - CLOSING NOTE [2015-03-16 Mon 17:51] \\
      Finished test log.
*** DONE Order of local Hessians in output
    CLOSED: [2015-03-16 Mon 18:08]
    - CLOSING NOTE [2015-03-16 Mon 18:08] \\
      Wrote email to Christian.
    - Note taken on [2015-02-26 Thu 15:12] \\
      Ask Christian if it is ok, if the local Hessians in the output are not always in the same order.
** DONE <2015-02-13 Fri> Merge bugfix branch into <hessians_pascal>
   CLOSED: [2015-02-16 Mon 16:20]
   - CLOSING NOTE [2015-02-16 Mon 16:20] \\
     Merged branch hessians_pascal_bugfix1 into hessians_pascal and deleted branch hessians_pascal_bugfix1.
** DONE <2015-01-19 Mon> Write extensive documentation about the Hessians
   CLOSED: [2015-02-16 Mon 13:49]
   - CLOSING NOTE [2015-02-16 Mon 13:49] \\
     Wrote an overview of all code related to the computation of Hessians: [[file:~/Documents/Work/docs/notes/hessians_implementation.pdf][Hessians implementation]]
*** Hessian data structures <2015-02-13 Fri>
The Hessians data is stored in form of local Hessians (matrices of size NDIMMAT).
**** Data structures for storing Hessians:
In =struct Particle= (see data.h):
- =double *localHessians= :: Pointer to an array of length =NDIMMAT x neighbors= which stores the entries of the local Hessians.
     For every neighbor Particle the Hessian \partial_p \partial_q is stored, where p is the Particle represented by the struct.
     All entries are stored in a rowwise manner: \partial_{p1}\partial_{q1} \partial_{p1}\partial_{q2} \partial{p1}\partial{q3} \partial_{p2}\partial{q1} \partial_{p2}\partial{q2} ...
- =trx_htab *hessianIndex= :: Pointer to a hash table which maps particle indices to the corresponding array entry in =localHessians=. This allows quick retrieval of local Hessians for each pair of Particle structs.
- =unsigned int sizeOfLocalHessians= :: Stores the maximal number of entries (not Hessians!) that can be stored by the =localHessian= array. This is important for cleaning of the data structures.
In =struct Problem= (see data.h):
- =int computeHessians= :: Flag that indicates if Hessians are computed (=1) in the simulation or not (=0).
**** Function for data structure handling:
In order to work with the Hessian data structures some "comfort functions" are implemented in =particle.c=:
- =void createLocalHessians(struct Particle *p, int numberOfHessians)= :: Allocates memory for the =localHessians= array and creates the =hessianIndex= hash table.
- =void destroyLocalHessians(struct Particle *p)= :: Frees memory for all entries of =localHessians= and destroys the =hessianIndex= hash table.
- =int getLocalHessian(struct Particle *p, unsigned int qIndex, double *values)= :: Gets the whole local Hessian \partial_p\partial_q and stores it in =values=.
- =double getLocalHessianComponent(struct Particle *p, unsigned int qIndex, unsigned int i, unsigned int j)= :: Returns the (i,j)-th entry of the local Hessian \partial_p\partial_q.
- =void cleanHashTable(trx_htab *table)= :: Frees the memory of all entries in =table=. The hash table itself is not destroyed. This is used to reinitialize =hessianIndex=.
- =void cleanLocalHessians(struct Particle *p)= :: Reinitializes the data structure for the Particle struct p.
- =void addLocalHessian(struct Particle *p, unsigned int qIndex, double *values)= :: Adds a new local Hessian matrix to Particle p.
**** Initialization of Hessian data structures:
The Hessian data structures are initialized during the creation of the Particle structs. A short overview of the overall structure of the initialization:
1. (tremolo.c): =int main()= calls =void Run(int argc, char **argv)= to start the simulation.
2. (tremolo.c): =static void Run(int argc, char **argv)= calls =void Init(struct Problem *P)= for the initialization of the main data structures.
3. (init.c): =void Init(struct Problem *P)= calls =void InitSimBox(struct Problem *P)= to add the Particle structs to the simulation.
4. (particle.c) =void InitSimBox(struct Problem *P)= calls =int ReadParticles(struct Problem *P, FILE *f, struct ParseInfoBlock *PIB)= which adds Particle structs according to the input file =*f=
5. (particle.c) =int ReadParticles(struct Problem *P, FILE *f, struct ParseInfoBlock *PIB)= creates all Particle structs for the simulation using =struct Particle *CreateParticleNoSpeStr(const struct Problem *P)= which allocates memory for a Particle struct and initializes some member variables.
The actual initialization is done in =struct Particle *CreateParticleNoSpeStr(const struct Problem *P)=. For this, the =computeHessian= flag of the Problem struct is checked.
According to the flag memory for the Hessian data structures is allocated or not. The size of the =localHessian= array is roughly estimated using the total number of Particles and the number of cells in the simulation.
**** Deletion of Hessian data structures:
The Hessian data structures are destroyed whenever the associated Particle struct is deleted. This is done especially at the end of the program:
1. (tremolo.c): =int main()= calls =void Run(int argc, char **argv)= to start the simulation.
2. (tremolo.c): =static void Run(int argc, char **argv)= calls =void RemoveEverything(struct Problem *P)= at the end of the program to free all allocated memory.
3. (helpers.c): =void RemoveEverythin(struct Problem *P)= calls =void DeleteLists(struct Problem *P)= to delete the linked cell structure.
4. (helpers.c): =void DeleteLists(struct Problems *P)= calls =void DeleteAllParticles(struct Problem *P, struct LCStructData *LCS)= in order to delete all Particle structs.
5. (helpers.c): =void DeleteAllParticles(struct Problem *P, struct LCStructData *LCS)= calls =void DeleteLCListRec()= which in turn calls =void DeleteParticle(const struct Problem * UNUSED(P), struct Particle *p)=.
The actual deletion of the Hessian data structures is done in =void DeleteParticle(const struct Problem * UNUSED(P), struct Particle *p)= (particle.c). For this, a NULL-check for the =localHessian= array is performed and then the memory of the Hessian data structures is freed.
*** Data structures for Hessian calculation <2015-02-16 Mon>
For the computation of Hessians every potential provides a function used for the calculation. These functions are stored in lists of structs which store the function pointers. Tremolo iterates at every time step over these lists and calls the function pointers.
The struct used for Hessian calculation is defined in lcforces.h
- =struct LCHessianList= :: Struct similar to =LCForceList= storing the function pointers and data necessary for the computation of Hessians. Every struct represents a given potential and a given pair of particles.
The list of =LCHessianList= structs is stored in the =LCForceParams= struct:
- =LCForceParams= :: is stored in the =Problem= struct (for different "stages").
- =LCForceData= :: Every =LCForceParams= struct stores an array of =LCForceData= structs. Every =LCForceData= struct represents a pair of particles.
- =LCHessianList= :: For every potential the =LCForceData= struct points to a =LCForceList= and to a =LCHessianList= struct which in turn store the function pointer for the calculation.
*** Registration of Hessian computation <2015-02-16 Mon>
For the computation of Hessians every potential must provide a function =Calc<Potentialname>Hessian= (cf. e.g. =CalcLennardJonesHessian()=).
This function must be registered such that tremolo can call it during the simulation. Since the potentials file is parsed before the parameter file the registration of the Hessian calculation function is done in two steps:
1. For all potentials in the potentials file (that provide Hessian calculation functions) the corresponding Hessian calculation function is registered regardless if Hessians are computed during the simulation.
2. If in the parameter file Hessian computation is disabled, all registered Hessian calculation functions are unregistered.
The registration process is done in the function =void ReadParameters(struct Problem * const P, const char *const filename)=.
**** Set default behaviour for Hessian computation.
If no tag "hessians" is provided in the parameters file then the Hessian computation is disabled:
1. (tremolo.c): =int main()= calls =void Run(int argc, char **argv)= to start the simulation.
2. (tremolo.c): =static void Run(int argc, char **argv)= calls =void ReadParameters(struct Problem *const P, const char *const filename)= in order to parse the input files.
3. (init.c): =void ReadParameter(struct Problem *const P, const char *const filename)= calls the function =void FirstInit(struct Problem *const P)=.
4. (init.c): =void FirstInit(struct Problem *const P)= sets =P->computeHessians = 0=: by default no Hessians are computed.
**** Registration of Hessian calculation functions
The actual registration of the Hessian calculation functions is done in the function =int ParsePotentialFiles(struct Problem *P)= (parse.c). The registration is done by each potential itself. For this the potential must implement the Hessian registration in the corresponding =Store<Potentialname>Data()= function (c.f. =StoreLennardJonesData()= (twobody.c)).
1. (tremolo.c): =int main()= calls =void Run(int argc, char **argv)= to start the simulation.
2. (tremolo.c): =static void Run(int argc, char **argv)= calls =void ReadParameters(struct Problem *const P, const char *const filename)= in order to parse the input files.
3. (init.c): =void ReadParameter(struct Problem *const P, const char *const filename)= calls =int ParsePotentialFiles(struct Problem *P)= which registers and calls for all potential the corresponding registration routines.
For the Lennard-Jones potential the registration is done in the following steps:
1. (init.c): =int ParsePotentialFiles(struct Problem *P)= calls =int Read2BodyPotentials(struct Problem *P, FilePosType *filePos, parse_data *pd)= which then in turn calls =int ReadLennardJonesData()=.
2. (twobody.c): =int ReadLennardJonesData()= calls =int StoreLennardJonesData()= which performs the registration of the function =static void CalcLennardJonesHessian()= using the function =int RegisterLCHessian()= (implemented in lcforces.c).
**** Check and possible deregistration of Hessian calculation functions
After parsing the potentials file and the registration of the Hessian calculation functions, the parameter file is parsed in =int ParseParameterFiles(struct Problem *P)=.
If the parameter file contains a =hessians= tag in the =analyze= block the =int StoreAnalyzeHessians()= function (in groupmeas.c) is called which sets the =computeHessians= flag of the Problem struct.
1. (tremolo.c): =int main()= calls =void Run(int argc, char **argv)= to start the simulation.
2. (tremolo.c): =static void Run(int argc, char **argv)= calls =void ReadParameters(struct Problem *const P, const char *const filename)= in order to parse the input files.
3. (init.c): =void ReadParameter(struct Problem *const P, const char *const filename)= calls =int ParseParameterFiles(struct Problem *P)=.
4. (parse.c): =int ParseParameterFiles(struct Problem *P)= parses the parameter file and calls =int StoreOutputAnalyze(struct Problem *P, FilePosType *filePos, parse_data *pd)=.
5. (generalmeas.c): =int StoreOutputAnalyze()= calls =int StoreAnalyzeHessians(struct Problem *P, FilePosType *filePos, parse_data *pd)= if a =hessians= tag is found in the parameter file. If no =hessians= tag is found the function is not called and the default value (= 0) is used.
5. (groupmeas.c): =int StoreAnalyzeHessians(struct Problem *P, FilePosType *filePos, parse_data *pd)= sets =P->computeHessians= to one or zero according to the value set in the parameter file.
After parsing the parameter file some control function are called within =int ParseParameterFiles(struct Problem *P)=. If no Hessians are supposed to be computed the Hessian calculation functions are here deregistrated:
1. (init.c): =void ReadParameter(struct Problem *const P, const char *const filename)= calls =int ParseParameterFiles(struct Problem *P)=.
2. (parse.c): =int ParseParameterFiles(struct Problem *P)= calls =void ControlParseParameterFiles(struct Problem *P)=.
3. (parse.c): =void ControlParseParameterFiles(struct Problem *P)= calls all =ControlParameterRecord= function pointers of the =ParamInit= array. This also includes the function =int ControlGroupMeasureRecord(struct Problem *P)=.
4. (groupmeas.c): =int ControlGroupMeasureRecord(struct Problem *P)= calls =int ControlHessianRecord(struct Problem *P)=.
5. (groupmeas.c): =int ControlHessianRecord(struct Problem *P)= deregisters all Hessian calculation functions if the =computeHessian=-flag is set to 0.
*** Computation and reinitialization of Hessians
The Hessian calculation is done for every time step in the =RunSim()= function:
1. (tremolo.c): =int main()= calls =void Run(int argc, char **argv)= to start the simulation.
2. (tremolo.c): =void Run(int argc, char **argv)= calls =static void RunSim(struct Problem *P)= which does all time steps.
3. (tremolo.c): =static void RunSim(struct Problem *P)= calls =void UpdateMeasureVisData(struct Problem *P)= which iterates over all =Particle= structs and reinitializes the =localHessians= arrays.
4. (tremolo.c): =static void RunSim(struct Problem *P)= calls =void MainLCForce(struct Problem *P)= which is the main function for linked cell force calculation.
5. (lcforces.c): =void MainLCForce(struct Problem *P)= calls =void CalcLCForce()= which iterates over all cells.
6. (lcforces.c): =void CalcLCForce()= calls for every cell =static void CalcLCForceForCell()= which iterates over all =Particles= in this cell.
7. (lcforces.c): =static void CalcLCForceForParticle()= iterates for all neighboring particles over all =LCForceList= and =LCHessianList= structs and calls the force/Hessian calculation function.
The calculation of the Hessians itself is done by a function which has to be defined for each potential. A pointer of this function is stored in the corresponding =LCHessianList= struct.
An example of such a function =static void CalcLennardJonesHessian(void *data, struct LCForceFunctionData *const LFFD)=:
The function computes for the given =Particle= pair (p,q) all local Hessians \partial_pp, \partial_pq, \partial_qp, \partial_qq which are then added to the =localHessians= arrays of the corresponding =Particle= structs.
The Hessians \partial_pp and \partial_pq are added to =Particle= p and the other two to q.
*** Output of Hessians
The Hessian-file suffix is declared data.h in the =enum OutputFileSuffixes= as =hessiansfile= and then defined in the function =void ReadParameters(struct Problem *const P, const char * const filename)=.
The output itself is done in a function =static void OutputFileHessians(struct Problem * P)=:
1. (tremolo.c): =int main()= calls =void Run(int argc, char **argv)= to start the simulation.
2. (tremolo.c): =void Run(int argc, char **argv)= calls =static void RunSim(struct Problem * P)= which does all time steps.
3. (tremolo.c): =static void RunSim(struct Problem * P)= calls =void OutputBeforeUpdate(struct Problem * P)=.
4. (output.c): =void OutputBeforeUpdate(struct Problem * P)= calls =void OutputV(struct Problem * P)=.
5. (output.c): =void OutputV(struct Problem * P)= calls =void OutputVisualData(struct Problem * P)=.
6. (output.c): =void OutputVisualData(struct Problem * P)= calls =static void OutputFileHessians(struct Problem * P)= which opens the .hessians file and writes for all =Particles= the local Hessians to that file.
** DONE <2015-01-30 Fri> Rewrite StoreAnalyzeHessians
   CLOSED: [2015-01-30 Fri 12:36]
   - CLOSING NOTE [2015-01-30 Fri 12:36] \\
     Wrote additional function ControlHessianRecord() in groupmeas.c such that the HList-Array is cleaned in this funtion and not while parsing.
     This seems to work. Checked this for a deactivated and a missing "hessians"-tag in the parameters file.
   - Note taken on [2015-01-30 Fri 12:01] \\
     Problem description:
     If in the parameters file no tag "hessians" is present, then StoreAnalyzeHessians() is not called because of the missing keyword.
     Therefore the "pruning" of the HLists must be done in an other function.

     Solution:
     The idea is that
     - StoreAnalyzeHessians() just sets the computeHessians-flag in the Problem struct
     - The actual pruning is done in the corresponding "control" function (must still be found).
** DONE <2015-01-28 Wed> Fix invalid reads/frees
   CLOSED: [2015-02-13 Fri 11:05]
   - CLOSING NOTE [2015-02-13 Fri 11:05] \\
     Fixed error concerning the jump caused by an uninitialized variable. The problem was an uninitialized file suffix.
1. valgrind auf testing -> jump caused by uninitialized


* Log

** Log <2015-04-29 Wed>
   :LOGBOOK:
   CLOCK: [2015-04-29 Wed 11:48]--[2015-04-29 Wed 21:00] =>  9:12
   :END:
** Log <2015-04-27 Mon>
   :LOGBOOK:
   CLOCK: [2015-04-27 Mon 14:09]--[2015-04-27 Mon 19:23] =>  5:14
   CLOCK: [2015-04-27 Mon 08:19]--[2015-04-27 Mon 12:49] =>  4:30
   :END:
** Log <2015-04-26 Sun>
   :LOGBOOK:
   CLOCK: [2015-04-26 Sun 14:13]--[2015-04-26 Sun 16:16] =>  2:03
   :END:
** Log <2015-04-24 Fri>
   :LOGBOOK:
   CLOCK: [2015-04-24 Fri 09:46]--[2015-04-24 Fri 12:45] =>  2:59
   :END:
** Log <2015-04-23 Thu>
   :LOGBOOK:
   CLOCK: [2015-04-23 Thu 14:17]--[2015-04-23 Thu 15:17] =>  0:00
   CLOCK: [2015-04-23 Thu 09:34]--[2015-04-23 Thu 11:19] =>  1:45
   :END:
** Log <2015-04-20 Mon>
   :LOGBOOK:
   CLOCK: [2015-04-20 Mon 16:44]--[2015-04-20 Mon 18:13] =>  1:29
   CLOCK: [2015-04-20 Mon 12:00]--[2015-04-20 Mon 13:48] =>  1:48
   :END:
** Log <2015-04-17 Fri>
   :LOGBOOK:
   CLOCK: [2015-04-17 Fri 16:47]--[2015-04-17 Fri 19:26] =>  2:39
   CLOCK: [2015-04-17 Fri 09:59]--[2015-04-17 Fri 12:35] =>  2:36
   :END:
** Log <2015-04-11 Sat>
   :LOGBOOK:
   CLOCK: [2015-04-11 Sat 15:42]--[2015-04-11 Sat 17:42] =>  2:00
   :END:
** Log <2015-03-27 Fri>
   :LOGBOOK:
   CLOCK: [2015-03-27 Fri 09:33]--[2015-03-27 Fri 11:42] =>  2:09
   :END:
** Log <2015-03-26 Thu>
   :LOGBOOK:
   CLOCK: [2015-03-26 Thu 16:26]--[2015-03-26 Thu 19:31] =>  3:05
   CLOCK: [2015-03-26 Thu 13:30]--[2015-03-26 Thu 15:53] =>  2:23
   :END:
** Log <2015-03-25 Wed>
   :LOGBOOK:
   CLOCK: [2015-03-25 Wed 12:58]--[2015-03-25 Wed 15:38] =>  2:40
   CLOCK: [2015-03-25 Wed 11:15]--[2015-03-25 Wed 12:33] =>  1:18
   :END:
** Log <2015-03-23 Mon>
   :LOGBOOK:
   CLOCK: [2015-03-23 Mon 14:30]--[2015-03-23 Mon 15:59] =>  1:29
   :END:
** Log <2015-03-22 Sun>
   :LOGBOOK:
   CLOCK: [2015-03-22 Sun 14:47]--[2015-03-22 Sun 17:43] =>  2:56
   :END:
*** MergeOutput.py script
**** Description
- i = time step (i0 = first time step, i1 = last time step)
- j = number of parallel jobs (j0 = first processor, j1 = last processor)
- =GetLimits()= :: Gets teh values for =i1, j1, i0, j0=; for this all files of the chose filetype are taken and sorted,
                   the last file name is split and the corresponding derived from that.
- l. 108 to 136 :: Parallel execution of the script.
- l. 154 to 161 :: Define lambda function for sorting the entries.
- MAIN LOOP ::
  1. iterate over all time steps
  2. iterate over all processors
     - store header
     - store all lines
     - if requested: remove file
  3. sort lines by keyfunc
  4. output file
  5. check output
**** Changes
- [X] Change parser arguments
- [X] Change hessians file name convention to =<PROJECTNAME>.hessians.XXXX=
- [X] Add hessians to =header_len, keycolumn_id=
- [X] Set key function for sorting
** Log <2015-03-19 Thu>
   :LOGBOOK:
   CLOCK: [2015-03-19 Thu 12:11]--[2015-03-19 Thu 13:33] =>  1:22
   :END:
** Log <2015-03-18 Wed>
   :LOGBOOK:
   CLOCK: [2015-03-18 Wed 13:09]--[2015-03-18 Wed 17:47] =>  4:38
   CLOCK: [2015-03-18 Wed 10:39]--[2015-03-18 Wed 12:05] =>  1:26
   :END:
** Log <2015-03-16 Mon>
   :LOGBOOK:
   CLOCK: [2015-03-16 Mon 14:39]--[2015-03-16 Mon 18:35] =>  3:56
   :END:
** Log <2015-03-14 Sat>
   :LOGBOOK:
   CLOCK: [2015-03-14 Sat 13:50]--[2015-03-14 Sat 15:07] =>  1:17
   CLOCK: [2015-03-14 Sat 10:58]--[2015-03-14 Sat 13:50] =>  2:52
   :END:
** Log <2015-03-13 Fri>
   :LOGBOOK:
   CLOCK: [2015-03-13 Fri 14:45]--[2015-03-13 Fri 18:19] =>  3:34
   CLOCK: [2015-03-13 Fri 09:09]--[2015-03-13 Fri 11:43] =>  2:34
   :END:
** Log <2015-03-12 Thu>
   :LOGBOOK:
   CLOCK: [2015-03-12 Thu 16:20]--[2015-03-12 Thu 18:20] =>  2:00
   :END:
** Log <2015-03-06 Fri>
   :LOGBOOK:
   CLOCK: [2015-03-06 Fri 15:33]--[2015-03-06 Fri 18:33] =>  3:00
   CLOCK: [2015-03-06 Fri 10:09]--[2015-03-06 Fri 12:33] =>  2:24
   :END:
** Log <2015-02-26 Thu>
   :LOGBOOK:
   CLOCK: [2015-02-26 Thu 17:34]--[2015-02-26 Thu 18:07] =>  0:33
   CLOCK: [2015-02-26 Thu 12:05]--[2015-02-26 Thu 17:34] =>  5:29
   :END:
** Log <2015-02-25 Wed>
   :LOGBOOK:
   CLOCK: [2015-02-25 Wed 16:44]--[2015-02-25 Wed 17:46] =>  1:02
   CLOCK: [2015-02-25 Wed 13:01]--[2015-02-25 Wed 16:43] =>  3:42
   CLOCK: [2015-02-25 Wed 12:50]--[2015-02-25 Wed 13:00] =>  0:10
   :END:
** Log <2015-02-20 Fri>
   :LOGBOOK:
   CLOCK: [2015-02-20 Fri 14:30]--[2015-02-20 Fri 17:46] =>  3:16
   CLOCK: [2015-02-20 Fri 09:20]--[2015-02-20 Fri 12:25] =>  3:05
   :END:
** Log <2015-02-16 Mon>
   :LOGBOOK:
   CLOCK: [2015-02-16 Mon 15:23]--[2015-02-16 Mon 18:27] =>  3:04
   CLOCK: [2015-02-16 Mon 10:39]--[2015-02-16 Mon 13:53] =>  3:14
   CLOCK: [2015-02-16 Mon 09:53]--[2015-02-16 Mon 10:39] =>  0:46
   :END:
** Log <2015-02-13 Fri>
   :LOGBOOK:
   CLOCK: [2015-02-13 Fri 14:01]--[2015-02-13 Fri 16:53] =>  2:52
   CLOCK: [2015-02-13 Fri 9:13]--[2015-02-13 Fri 11:51] =>  2:38
   :END:
** Log <2015-01-30 Fri>
   :LOGBOOK:
   CLOCK: [2015-01-30 Fri 18:19]--[2015-01-30 Fri 18:19] =>  0:00
   CLOCK: [2015-01-30 Fri 16:30]--[2015-01-30 Fri 17:58] =>  1:28
   CLOCK: [2015-01-30 Fri 09:11]--[2015-01-30 Fri 12:45] =>  3:34
   :END:

*** Rewrote StoreAnalyzeHessians <2015-01-30 Fri>
1. Simplified StoreAnalyzeHessians() in groupmeas.c: The function now only checks if the tag "hessians" in the parameters file is set or not and changes the "computeHessians"-flag in the Problem struct accordingly.
2. Added function ControlHessianRecord() to groupmeas.c: The function checks if "computeHessians"-flag is set to true and if not cleans the HList-array s.t. no Hessians are computed.
3. Added function call of ControlHessianRecord() to ControlGroupMeasureRecord() in groupmeas.c.
** Log <2015-01-28 Wed>
   :LOGBOOK:
   CLOCK: [2015-01-28 Wed 10:26]--[2015-01-28 Wed 15:44] =>  5:18
   :END:
*** Fix bug if hessians: measure=off; is set in parameters file
** Log <2015-01-23 Fri>
   :LOGBOOK:
   CLOCK: [2015-01-23 Fri 17:00]--[2015-01-23 Fri 19:10] =>  2:10
   CLOCK: [2015-01-23 Fri 09:30]--[2015-01-23 Fri 12:50] =>  3:20
   :END:
*** Hessian testing
** Log <2015-01-21 Wed>
   :LOGBOOK:
   CLOCK: [2015-01-21 Wed 15:42]--[2015-01-21 Wed 17:18] =>  1:36
   :END:
*** Started Hessian-testing log-file in [[file:hessians/tests/test.org]] and set testing parameters
** Log <2015-01-19 Mon>
   :LOGBOOK:
   CLOCK: [2015-01-19 Mon 17:16]--[2015-01-19 Mon 19:03] =>  1:47
   CLOCK: [2015-01-19 Mon 13:02]--[2015-01-19 Mon 13:14] =>  0:12
   CLOCK: [2015-01-19 Mon 11:30]--[2015-01-19 Mon 12:59] =>  1:29
   :END:
*** Generate test environment for Hessian-testing
- File for Hessian tests: [[file:~/Sandbox/testHessians/][testHessians]]


* Working hours
** Clocktable
#+BEGIN: clocktable :maxlevel 2 :scope file :block thisweek
#+CAPTION: Clock summary at [2015-04-30 Thu 00:11], for week 2015-W18.
| Headline                   | Time    |      |
|----------------------------+---------+------|
| *Total time*               | *18:56* |      |
|----------------------------+---------+------|
| Log                        | 18:56   |      |
| \emsp Log <2015-04-29 Wed> |         | 9:12 |
| \emsp Log <2015-04-27 Mon> |         | 9:44 |
#+END:

** Summary
| Week     |      Time |  Overtime |
|----------+-----------+-----------|
| 2015-W02 |      8:05 | -00:55:00 |
| 2015-W03 |      6:06 | -02:54:00 |
| 2015-W04 |     10:34 |  01:34:00 |
| 2015-W05 |     10:20 |  01:20:00 |
| 2015-W06 |      0:00 | -09:00:00 |
| 2015-W07 |      5:30 | -03:30:00 |
| 2015-W08 |     22:25 |  13:25:00 |
| 2015-W09 |     10:56 |  01:56:00 |
| 2015-W10 |      5:24 | -03:36:00 |
| 2015-W11 |     12:17 |  03:17:00 |
| 2015-W12 |     14:18 |  05:18:00 |
| 2015-W13 |     13:04 |  04:04:00 |
| 2015-W14 |         0 | -09:00:00 |
| 2014-W15 |     11:00 |  02:00:00 |
| 2014-W16 |      5:15 | -03:45:00 |
| 2014-W17 |     11:04 |  02:04:00 |
| 2014-W18 |      9:44 |  00:44:00 |
|----------+-----------+-----------|
| Total    | 156:02:00 |  03:02:00 |
#+TBLFM: $3=$2-9*3600;T::@>$2=vsum(@2$2..@-1$2);T::@>$3=vsum(@2$3..@-1$3);T::
