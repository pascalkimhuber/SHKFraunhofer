#+STARTUP: logdone
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper]

* Organization

** Commit conventions
1. Name branch I am working in.
2. Be explicit about what has been done.
3. Mark if a "project" is finished.


* Configurations


* Emacs

** Language evaluation in org mode (see http://zeekat.nl/articles/making-emacs-work-for-me.html#sec-10)
** DONE Qt Auto complete
   CLOSED: [2014-04-16 Wed 15:04]

** TODO Syntax highlighting for doxygen comments in c++ mode.

** TODO Setter and getter methods.

** TODO Rewrite Arbeitszeiten section


* Nuetzliches

** Konventionen für Tremolo Code (Kommentare, Coding Guidlines)
- Zum Einrücken immer nur 2 Leerzeichen verwenden. (Habe das bereits in Emacs geändert.)


** Tremolo und tremologui aktualisieren

Nachdem eine neue Version des Tremolo-Ordners gepullt wurde, kann Tremolo wie folgt aktualisiert werden:
: cd ~/tremolo/build
: make && make install

Das selbe gilt für Tremologui.
: cd ~/tremologui/build
: make && make install

In seltenen Fällen muss evtl. auch die CMake-Datei neu erzeugt werden: Dafür im build-Ordner:
: ccmake ..

Momentan sind die Pfadvariablen so eingestellt, dass die binaries in /home/huber/bin kopiert werden. Das kann man im ccmake Menu unter install_prefix ändern.


** Neue source und header Dateien in Tremolo einbinden
Dateien zunächst in [[file:~/tremolo/src]] einfügen, dann die Source-Datei in [[file:~/tremolo/CMakeLists.txt]] hinzufügen.


** Tremolo testen
Für self-tests von Tremolo kann das Programm runpybbt.py in [[~/tremolo/build/tests/]] verwendet werden.


** CTags in Emacs
In order to create the tags I ran the following command:
: find. -type f -iname "*.[xhS]" |xargs etags -a

In emacs ctags can be handled with the following commands:
- =M-. <RET>= :: Jump to the tag underneath the cursor.
- =M-. <tag> <RET>= :: Search for a particular tag.
- =C-u M-.= :: Find the next definition for the last tag.
- =M-*= :: Pop back where you previously invoked "M-.".



** Visualisieren von Tremolodaten
Dazu kann das Programm VMD verwendet werden: VMD visualisiert .xyz und .pdb Files:
: vmd *.xyz
Die graphische Anpassung kann in VMD unter Graphics->Representation angepasst werden.


** Gnuplot Befehle

Einen Ueberblick zu nuetzlichen Gnuplot Befehlen kann auf der folgenden Seite gefunden werden: http://people.duke.edu/~hpgavin/gnuplot.html

1. Um ein Data-file (zum Beispiel =*.epot*=) mit Gnuplot zu plotten, verwendet man: \\
   : gnuplot> plot "./argon.epot" using 1:2
   Hierbei wird die zweite Spalte gegen die erste Spalte aufgetragen.
2. Dies kann auch mit mehreren Files gleichzeitig getan werden: \\
   : gnuplot> plot "./argon.etot" using 1:2, "./argon.ekin" using 1:2, "./argon.epot" using 1:2
3. Um den Achsenabschnitt zu veraendern, verwendet man: \\
   : gnuplot> plot "./argon.epot" using 1:2; set yrange [-0.1: 2]
4. Den urspruenglichen Achsenabschnitt kann man wie folgt wieder herstellen: \\
   : gnuplot> plot "./argon.epot" using 1:2; set autoscale
5. Mit \\
   : gnuplot> replot
   kann der Plot aktualisiert werden.
6. Eine Uebersicht von =set= Befehlen:
   Create a title:
   : set title "Force-Deflection Data"
   Put a label on the x-axis:
   : set xlabel "Deflection (meters)"
   Put a label on the y-axis:
   : set ylabel "Force (kN)"
   Change the x-axis range:
   : set xrange [0.001:0.005]
   Change the y-axis range:
   : set yrange [20:500]
   Have Gnuplot determine ranges:
   : set autoscale
   Move the key:
   : set key 0.01,100
   Delete the key:
   : unset key
   Put a label on the plot:
   : set label "yield point" at 0.003, 260
   Remove all labels:
   : unset label
   Plot using log-axes:
   : set logscale
   Plot using log-axes on y-axis:
   : unset logscale; set logscale y
   Change the tic-marks:
   : set xtics (0.002,0.004,0.006,0.008)
   Return to the default tics:
   : unset xtics; set xtics auto
   Set output:
   : set output 'introduction.png'


** Grep Befehle

http://www.panix.com/~elflord/unix/grep.html


** Git Befehle

*** Branches
- Create a new branch:
  : git branch <name_of_new_branch>
- Create a new branch by pulling from a remote branch:
  : git checkout -b <name_of_new_branch> origin/<name_of_branch>
- Delete a local branch:
  : git branch -d <name_of_branch>
- Naming convention: use well defined tokes like
  : feature
  : bugfix
  : test
  followed by a slash '/' and a describing name, e.g.:
  : feature/potentials

*** Diff
- Show differences between <branch1> and <branch2>
  : git diff <branch1>..<branch2>

*** Manipulate changes.
- Remove untracked files:
  : git clean -f -d

*** Add and remove changes.
- Remove deleted files from stack:
  : git add -u .

*** Remote repositories
- Add remote repository with name /origin/ (e.g. https://pascalkimhuber@bitbucket.org/pascalkimhuber/stacked.git)
  : git remote add origin <address of remote>
- Push a local repository to a remote repository with name /origin/ for the first time
  : git push -u origin --all

*** Merging branches
- Merge <branch1> into <branch2>
  : git checkout <branch2>
  : git merge <branch1>


** Find Befehle

- Find all files with names containing =<pattern>= (wildcards have to be used with a preceeding backslash!):
  : find -name <pattern>
  or e.g.
  : find -name <pattern>\*


** Doxygen Befehle

- [[http://www.stack.nl/~dimitri/doxygen/manual/commands.html#cmdc][List of special commands]]


** GDB Befehle

*** Within GDB
Start the TUI (see source code and output)
: CTRL-x a
or just
: win


* Aufgaben

** DONE Learn Dakota
   CLOSED: [2014-09-12 Fri 11:27]
   CLOCK: [2014-07-29 Tue 14:09]--[2014-07-29 Tue 17:48] =>  3:39
   CLOCK: [2014-07-23 Wed 14:00]--[2014-07-23 Wed 16:56] =>  2:56
   CLOCK: [2014-07-22 Tue 14:00]--[2014-07-22 Tue 17:22] =>  3:22
   - Note taken on [2014-08-20 Wed 15:56] \\
     Treffen mit Christian am 20.08.2014

     Weiteres Vorgehen:
     1. Abschluss der Sampling Methoden
     2. Details zu den Intervall-Methoden:
        - Kosten
        - Lokale vs. Global (beides ausprobieren)
     3. Weitere Recherche zu sensitivity analysis: Main variables...
   - Note taken on [2014-08-13 Wed 15:38] \\
     Besprechung mit Christian am 13.08.2014, 15:00 Uhr
     1. Festlegung der Parameter Variablen und Response functions.
        Wird die Simulation als Blackbox betrachtet, ist folgender Input für die Analyse von Bedeutung:
        - (1 - n) Diffusionskoeffizienten + Unschärfe, d.h.
          D_0 + \Delta D_0, D_1 + \Delta D_1, D_2 + \Delta D_2, ... ,
          wobei n wahrscheinlich bei 1 - 10 liegt.
        - (1 - n) Gradienten von Chemischen Potenzialen + Unschärfe, d.h.
          \nable \mu_0 + \Delta \nabla \mu_0, \nable \mu_1 + \Delta \nabla \mu_1, \nable \mu_2 + \Delta \nabla \mu_2,...
        Als Output erhalten wir den (elektrischen) Fluss.
        Notizen: Die Diffusionskoeffizienten sind in der Simulation von der Konzentration abhängig. Wir erhalten als Datensätze die Werte von Diffusionskoeffizient+Unschärfe und vom chemischen Potenzial+Unschärfe für verschiedene Konzentrationswerte.
        Die Anzahl der Input Variablen hängt somit auch von der Genauigkeit der Datensätze ab: Bei geringer Genauigkeit kann es sein, dass eine Änderung der Konzentration nicht einen anderen Wert des Diffusionskoeffizienten erfordert.
        Mögliches Szenario wäre also z. Bsp.
        - Input:
          - D_0, D_1, D_2, D_3
          - mu_0, mu_1, mu_2
        - Output:
          - Fluss
        Die Samples müssen dann dem durch die Unschärfen definierten Bereichen entnommen werden.
     2. Aufgabe.
        Ich soll die von Dakota bereitgestellten Methoden von UQ, Parameter Studies, DoE, Sensitivity Analysis durchsuchen und nach geeigneten Methoden suchen.
        Es sollen folgende Aussagen gemacht werden können:
        - Welche Parameter (welche Diffusionskoeffizienten, welche Potentiale) sind entscheidend für den Fluss?
        - Wie sensibel ist der Output gegenüber den Veränderungen an den Input Variablen?
   - Note taken on [2014-07-23 Wed 17:00] \\
     All notes can be found in [[file:~/dakota/dakota-notes/notes.org][this]] org file.
   - Note taken on [2014-07-22 Tue 17:11] \\
     Aufgabenbeschreibung:

     Im Zuge einer Software zur Ionen-Migration (Berechnung über die Poisson-Nernst-Planck Gleichung) soll ein script geschrieben werden, dass als Input Diffusionswerte, chemisches Potential und erwartete Fehler entgegennimmt und anschließend den elektrischen Fluß bestimmt.
     Dazu soll das Optimierungsprogramm DAKOTA (Design Analysis Kit for Optimization and Terascale Applications) von den SNL verwendet werden.

     Meine Aufgabe ist es nun
     1. Mache mich Dakota vertraut
        + Lese das gesamte Manual (Version 5.4).
        + Schaue, was für das obige Problem wichtig sein kann.
     2. Schreibe ein Script (nach Absprache mit Christian)

     _Poisson-Nernst-Planck Gleichung_
     \partial_t c = \nabla [D (\nabla c + \alpha \nabla \phi + \beta c \nabla \mu )]
     \Delta \phi = \sum_i z_i c_i
*** DONE Installiere Dakota
    CLOSED: [2014-07-23 Wed 16:56]
Problem: Falsche Boost Version?

*** DONE Make short overview about Dakota
    CLOSED: [2014-08-05 Tue 10:13] SCHEDULED: <2014-07-24 Thu>
**** DONE Do Second Part of Dakota Tutorial (Chapter two of the manual)
     CLOSED: [2014-08-04 Mon 10:43] SCHEDULED: <2014-07-31 Thu 8:00-12:00>
     CLOCK: [2014-08-04 Mon 10:19]--[2014-08-04 Mon 10:43] =>  0:24
     CLOCK: [2014-07-31 Thu 10:04]--[2014-07-31 Thu 11:55] =>  1:51
     CLOCK: [2014-07-30 Wed 17:52]--[2014-07-30 Wed 19:34] =>  1:42
     CLOCK: [2014-07-30 Wed 15:45]--[2014-07-30 Wed 16:25] =>  0:40
     CLOCK: [2014-07-30 Wed 15:20]--[2014-07-30 Wed 15:30] =>  0:10
     CLOCK: [2014-07-30 Wed 14:34]--[2014-07-30 Wed 15:20] =>  0:46
*** DONE Learn about the Poisson-Nernst-Planck Equation and ionic migration
    CLOSED: [2014-08-06 Wed 09:08] SCHEDULED: <2014-08-02 Sat>
    CLOCK: [2014-08-04 Mon 09:09]--[2014-08-04 Mon 10:12] =>  1:03
The theory can be found in [[file:~/dakota/dakota-notes/diplom_neuen.pdf][Christians diploma thesis]].

*** TODO Read Chapter about Parameter studies and UQ
    SCHEDULED: <2014-08-04 Mon 8:00-12:00>
    CLOCK: [2014-08-06 Wed 14:00]--[2014-08-06 Wed 14:38] =>  0:38
    CLOCK: [2014-08-04 Mon 11:41]--[2014-08-04 Mon 12:49] =>  1:08
    CLOCK: [2014-08-04 Mon 10:44]--[2014-08-04 Mon 11:12] =>  0:28
    - Note taken on [2014-07-31 Thu 11:51] \\
      Meeting with Christian Thu, 31 Jul 2014 11:30

      - How to read correlation matrices in Figure 2.10
      - Read everything about parameter studies and uncertainty quantification (design of experiments)
      - aim: star correlations for diffusion D and chemical potential \mu in dependance of the concentration
        - are there such a thing?
        - want to know: if D differs 5% to above, how much does the flux F change?
**** DONE Finish Chapter about Parameter Studies (do some examples)
     CLOSED: [2014-08-05 Tue 12:44] SCHEDULED: <2014-08-05 Tue 8:00-13:00>
     CLOCK: [2014-08-05 Tue 10:00]--[2014-08-05 Tue 12:43] =>  2:43
**** DONE What does the correlation matrices mean?
     CLOSED: [2014-08-13 Wed 15:58]
     CLOCK: [2014-08-13 Wed 13:20]--[2014-08-13 Wed 15:58] =>  2:38
     CLOCK: [2014-08-13 Wed 10:35]--[2014-08-13 Wed 12:20] =>  1:45
     Notes can be found in the [[file:~/dakota/dakota-notes/notes.org][Dakota-Notes-file]].
**** DONE Read Chapter 5 about Uncertainty Quantification Capabilites [3/3]
     CLOSED: [2014-08-23 Sat 14:18] SCHEDULED: <2014-08-20 Wed 08:00-13:00>
     CLOCK: [2014-08-21 Thu 09:18]--[2014-08-21 Thu 10:19] =>  1:01
     CLOCK: [2014-08-20 Wed 15:00]--[2014-08-20 Wed 15:55] =>  0:55
     CLOCK: [2014-08-19 Tue 13:30]--[2014-08-19 Tue 14:59] =>  1:29
     CLOCK: [2014-08-19 Tue 11:06]--[2014-08-19 Tue 12:30] =>  1:24
     CLOCK: [2014-08-16 Sat 10:25]--[2014-08-16 Sat 12:03] =>  1:38
     CLOCK: [2014-08-15 Fri 09:30]--[2014-08-15 Fri 11:37] =>  2:07
     CLOCK: [2014-08-14 Thu 13:30]--[2014-08-14 Thu 14:09] =>  0:39
     CLOCK: [2014-08-14 Thu 10:42]--[2014-08-14 Thu 12:12] =>  1:30
     CLOCK: [2014-08-13 Wed 16:43]--[2014-08-13 Wed 16:47] =>  0:04
     CLOCK: [2014-08-13 Wed 16:00]--[2014-08-13 Wed 16:43] =>  0:43
***** DONE Read Chapter 5.5 about Importance Sampling
      CLOSED: [2014-08-21 Thu 13:38] SCHEDULED: <2014-08-21 Thu 8:00-12:00>
      CLOCK: [2014-08-21 Thu 13:15]--[2014-08-21 Thu 13:37] =>  0:22
      CLOCK: [2014-08-21 Thu 10:19]--[2014-08-21 Thu 12:24] =>  2:05
***** DONE Read Chapter 5.6 about Adaptive Sampling
      CLOSED: [2014-08-21 Thu 13:38] SCHEDULED: <2014-08-21 Thu 08:00-12:00>
***** DONE Investigate Interval Analysis again
      CLOSED: [2014-08-23 Sat 14:18] SCHEDULED: <2014-08-22 Fri 08:00-12:00>
      CLOCK: [2014-08-23 Sat 10:00]--[2014-08-23 Sat 14:18] =>  4:18

**** DONE Read userguidlines for sampling, DACE, see Chapter 4.7, Table 4.4
     CLOSED: [2014-08-24 Sun 12:22]
**** TODO Read Chapter 4 about Design of Experiments (do some examples)
     SCHEDULED: <2014-08-07 Thu 08:00-13:00>
     CLOCK: [2014-08-25 Mon 09:30]--[2014-08-25 Mon 12:10] =>  2:40
     CLOCK: [2014-08-06 Wed 09:49]--[2014-08-06 Wed 12:00] =>  2:11
***** DONE Read Chapter 4.6 about Sensitivity Analysis
      CLOSED: [2014-08-24 Sun 12:06]
      CLOCK: [2014-08-24 Sun 09:00]--[2014-08-24 Sun 12:30] =>  3:30
***** DONE Read again Chapter about Orthogonal Arrays and make an example
      CLOSED: [2014-08-26 Tue 20:17]
      CLOCK: [2014-08-26 Tue 15:00]--[2014-08-26 Tue 20:17] =>  5:17
***** DONE Write down the summaries
      CLOSED: [2014-08-26 Tue 20:17]
***** TODO Check on VBD + stochastic expansion (section 5.4)
***** TODO Review everything related to Sensitivity Analysis and finish the other third party software
      CLOCK: [2014-08-28 Thu 13:44]--[2014-08-28 Thu 17:10] =>  3:26
**** TODO Write out all methods that display correlation matrices etc.


** DONE Write Dakota Files for CCD/BB and interval analysis
   CLOSED: [2014-09-24 Wed 10:08] SCHEDULED: <2014-09-16 Tue>
   CLOCK: [2014-09-23 Tue 14:30]--[2014-09-23 Tue 15:35] =>  1:05
   CLOCK: [2014-09-22 Mon 13:30]--[2014-09-22 Mon 17:30] =>  4:00
   CLOCK: [2014-09-22 Mon 10:55]--[2014-09-22 Mon 12:30] =>  1:35
   CLOCK: [2014-09-21 Sun 19:00]--[2014-09-21 Sun 20:50] =>  1:50
   CLOCK: [2014-09-19 Fri 14:00]--[2014-09-19 Fri 17:00] =>  3:00
   CLOCK: [2014-09-19 Fri 10:30]--[2014-09-19 Fri 12:44] =>  2:14
   CLOCK: [2014-09-18 Thu 15:00]--[2014-09-18 Thu 16:05] =>  1:05
Write two dakota input files with good documentation
- one for sensitivity analysis CCD or BB
- one for interval analysis
Both files should use as interface a shell script called "npnp" and should have two dimensional parameters \(D\) and \(\mu\).
Furthermore I should investigate if both analysis can be combined.
It seems that both methods can be written into one file. See this example [[file:~/dummi/rosen_ccd.in][here]].
*** TODO Examine differences between hybrid etc.


** DONE Bug in tremologui
   CLOSED: [2014-10-28 Tue 09:56]
   - Note taken on [2014-10-17 Fri 12:06] \\
     Notes:
     Created bug issue in redmine.
     Note that in the Simulation Parameters tab, under Integration and domain, the cube is not displayed!


** TODO Add Hessians to tremolo
   CLOCK: [2014-10-15 Wed 16:14]--[2014-10-15 Wed 16:23] =>  0:09
   CLOCK: [2014-09-23 Tue 15:35]--[2014-09-23 Tue 17:23] =>  1:48
   - Note taken on [2014-10-01 Wed 15:00] \\
     Aufgabenbesprechung mit Christian am [2014-10-01 Wed 15:00]

     1. Grundaufgabe:
        - Füge Datenstrukturen für lokale Hesse-Matrizen und zugehörige particle-Matrix-Map (Hashmap) zum Particle-struct hinzu.
        - Die Berechnung der Hesse-Matrix sollte für das Lennard-Jones-Potential in CalcLCForceForParticle aus lcforces.c geschehen. Beachte dabei:
          + Flag-Abfrage: Hessian or noHessian?
          + Finde heraus was und wo die Registrierung der Kraftfunktion dabei ist.

     2. Anmerkungen:
        - hash-tables etc. finden sich in [[file:~/tremolo/src/hash/hashtab.h]]

     3. Sonstiges:
        - Vertragsverlängerung: Christian und ich haben jetzt erst einmal eine Vertragsverlängerung von 3 Monaten festgelegt. Wir wraten jetzt zunächst die nächsten 2 Wochen zum endgültigen Entschluss ab.
*** Overview
**** Basics:
Consider a system of \(N\) particles \(p_1, ..., p_N\). Then a (simple) general potential \(V\) can be written as:
\[V(p_1, ..., p_N) = \sum_{i=1}^N \sum_{j = i+1}^N U_{i,j}(p_i, p_j),\]
where \(U_{i,j}\) is the pair potential between the particles \(i\) and \(j\).

**** Ideas:
1. It is enough to consider pair potentials for the Hessians:
\[ \partial_p \partial_q V = \partial_p \partial_q U_{p,q}, \]
\[ \partial_p \partial_p V = \partial_p \partial_p \sum_{q\neq p} U_{p,q}. \]
2. Storing of the Hessians.
   - Every particle stores an array of matrices with the name 'Hessians'
   - Every particle stores a map, which mpas particle indices to array indices of 'Hessians'.

**** Questions: [1/2]
1. [X] What are the access times for map-containers?
   /Ordered map: logarithmic in size. Unordered map: constant (average case), linear in size (worst case).
2. [ ] Which operations should be possible for the Hessians?

*** DONE Understand what potentials exist, how and where they are computed.
    CLOSED: [2014-10-01 Wed 15:05]
    CLOCK: [2014-10-01 Wed 09:00]--[2014-10-01 Wed 13:19] =>  4:19
    CLOCK: [2014-09-24 Wed 10:00]--[2014-09-24 Wed 12:45] =>  2:45
A summary can be found [[file:hessians.pdf][here. ]]

*** DONE Have a look at the hash-table implementation in tremolo and hash-map implementations in general [3/3]
    CLOSED: [2014-10-15 Wed 16:14]
    CLOCK: [2014-10-15 Wed 15:42]--[2014-10-15 Wed 16:14] =>  0:32
    CLOCK: [2014-10-15 Wed 14:25]--[2014-10-15 Wed 15:42] =>  1:17
    CLOCK: [2014-10-15 Wed 11:41]--[2014-10-15 Wed 12:49] =>  1:08
    CLOCK: [2014-10-15 Wed 11:00]--[2014-10-15 Wed 11:40] =>  0:40
    CLOCK: [2014-10-14 Tue 15:11]--[2014-10-14 Tue 16:00] =>  0:49
    CLOCK: [2014-10-13 Mon 17:00]--[2014-10-13 Mon 19:03] =>  2:03
    CLOCK: [2014-10-09 Thu 17:00]--[2014-10-09 Thu 19:02] =>  2:02
    CLOCK: [2014-10-08 Wed 13:45]--[2014-10-08 Wed 18:57] =>  5:12
    CLOCK: [2014-10-07 Tue 14:15]--[2014-10-07 Tue 16:03] =>  1:48

A description and an example showing the usage of the hash table can be found at [[http://burtleburtle.net/bob/hash/hashtab.html]]

**** DONE Have a close look at the code of Bob Jenkins and do all examples
     CLOSED: [2014-10-13 Mon 18:28]
The code can be found in [[file:~/Work/playground/hashtab/]].

**** DONE Try an example
     CLOSED: [2014-10-13 Mon 18:28]

**** DONE Look at code examples from tremolo
     CLOSED: [2014-10-15 Wed 14:25]
The trx_hcreate function is used in the following files (without hash-file):

huber@ram:~/tremolo/src$ grep -ri hashtab.h *
- bondforces.c:#include "hash/hashtab.h", bondforces.h:#include "hash/hashtab.h"
  Hier wird htab für BondTable, AngleTable, TorsionTable und ImporoperTable verwendet.
  Viele Code-Beispiele vorhanden.
- data.h:#include "hash/hashtab.h"
  Verwendung von trx_htab *ParticleNames in struct MoleculeParameter.
- lcforces.c:#include "hash/hashtab.h"
  Einbindung der Headerdatei hash/hashtab.h, ansonsten wird die Hash map nicht benutzt.
- parse.c:#include "hash/hashtab.h"
  Hier werden geparste Particle Names in den struct MoleculeParameter und preziser in trx_htab *ParticleNames hinzugefügt.
  Hier gibt es vielleicht ein paar kleine Code-Beispiele, wie ich die hash table Funktionen verwenden kann.
- reaxff.c:#include "hash/hashtab.h"
- SuCh.c:#include "hash/hashtab.h"
- tersoff.c:#include "hash/hashtab.h"

*** DONE Overview of Particle struct and force computation in tremolo.
    CLOSED: [2014-10-15 Wed 16:14]
    CLOCK: [2014-09-24 Wed 13:30]--[2014-09-24 Wed 14:30] =>  1:00

**** DONE Have a look at particle.c and particle.h
     CLOSED: [2014-10-15 Wed 16:14]
     CLOCK: [2014-10-01 Wed 14:25]--[2014-10-01 Wed 15:06] =>  0:41

**** TODO Have a look at the force computation in tremolo.

*** DONE Add data structures to Particle struct in data.h
    CLOSED: [2014-10-15 Wed 16:14]

*** DONE Write small testing case
    CLOSED: [2014-10-16 Thu 18:53]
    CLOCK: [2014-10-16 Thu 16:43]--[2014-10-16 Thu 18:53] =>  2:10
The example can be found in [[file:~/Sandbox/2ArgonMolecules]]
*** DONE Add Hessian Flag to tremolo [3/3]
    CLOSED: [2014-10-21 Tue 14:32]
    CLOCK: [2014-10-17 Fri 15:29]--[2014-10-17 Fri 16:07] =>  0:38
    CLOCK: [2014-10-17 Fri 13:40]--[2014-10-17 Fri 15:29] =>  1:49
    CLOCK: [2014-10-17 Fri 10:37]--[2014-10-17 Fri 12:30] =>  1:53
**** DONE Add a Flag "computeHessians" into the Problem struct.
     CLOSED: [2014-10-17 Fri 15:58]
**** DONE Add a keyword to the tremolo parameter file. [2/2]
     CLOSED: [2014-10-17 Fri 16:01]
- [X] Change parameter file.
- [X] Change documentation (such that the flag is included)
**** DONE Add option to the parser routines. [2/2]
     CLOSED: [2014-10-21 Tue 13:35]
     CLOCK: [2014-10-21 Tue 11:10]--[2014-10-21 Tue 14:35] =>  3:25
- [X] Function StoreAnalyzeHessians in groupmeas.c has to be changed such that the hessian-flag in the Problem struct is changed.
- [X] Ask Christian about install process for tremolo. Get error if I try make install...
*** DONE Füge Komfortfunktionen zu particle.c hinzu [8/8]
    CLOSED: [2014-11-13 Thu 16:00]
    CLOCK: [2014-11-05 Wed 15:54]--[2014-11-05 Wed 18:15] =>  2:21
    CLOCK: [2014-11-04 Tue 14:16]--[2014-11-04 Tue 16:04] =>  1:48
    CLOCK: [2014-11-04 Tue 12:32]--[2014-11-04 Tue 12:52] =>  0:20
    CLOCK: [2014-11-04 Tue 10:00]--[2014-11-04 Tue 12:32] =>  2:32
    CLOCK: [2014-10-30 Thu 16:53]--[2014-10-30 Thu 17:52] =>  0:59
    CLOCK: [2014-10-29 Wed 10:00]--[2014-10-29 Wed 12:51] =>  2:51
    CLOCK: [2014-10-28 Tue 13:35]--[2014-10-28 Tue 15:31] =>  1:56
    CLOCK: [2014-10-28 Tue 08:30]--[2014-10-28 Tue 12:01] =>  3:31
    - Note taken on [2014-10-29 Wed 12:21] \\
      Note that the hashkey length used in the Hessian hashtable in the particle struct is defined in [[file:~/tremolo/src/particle.c]].
      #+BEGIN_SRC C
      #define HASH_KEYLEN 32
      #+END_SRC
**** DONE =void *createLocalHessians(struct Particle *p, int numberOfHessians)=
     CLOSED: [2014-10-29 Wed 11:50]
The routine should be called whenever a new Particle struct is created, but only if the flat =computeHessians= in the Problem struct is set to 1.
1. Allocate memory for a double array of size =NDIMMAT x numberOfNeighbors=
   and assign it to the =localHessians= pointer of =p=. The number of entries is stored to =p->sizeOfLocalHessians=.
   - In order to initialize the array with zeros use =Calloc= for memory allocation.
2. Create a =trx_htab= of size greater than =numberOfNeighbors= and assign it to the =hessianIndex= pointer of =p=.
   - Since the size of the hashtable is given by 2^(logsize) first the binary logarithm of =numberOfNeighbors= must be calculated.
   - In order that the hashtable is large enough the final logsize is given by =log2(numberOfNeighbors)+2=.

**** DONE =void destroyParticleHessians(struct Particle *p)=
     CLOSED: [2014-10-29 Wed 12:08]
The routine should be called whenever a Particle struct is destroyed and memory for Hessians was allocated.
1. Free all memory of the =localHessians= array. For this the customized =Free= routine in =util.h= is used.
2. Destroy =hessianIndex= hashtable and free all its memory.
   - Before destroying the hashtabe itself all items have to be deleted and freed in a while loop.
   - After that the hashtable can be destroyed using =trx_hdestroy()=.
**** DONE =int getLocalHessian(struct Particle *p, unsigned int qIndex, double *values)=
     CLOSED: [2014-11-04 Tue 11:22]
The routine is supposed to get all =NDIMMAT= entries of the local Hessian \(\partial_p \partial_qIndex V\) and store them in =values=. If =qIndex= is not found in the =hessianIndex= hashtable an zero-array is stored in =values= and in this case the routine returns 0. In all other cases it returns 1.
Note that the caller has to make sure that =values= is large enough (size =NDIMMAT=).
1. Convert =qIndex= into a =unsigned char= variable in order to find the right item in the hashtable. (The key in the hashtables are =unsigned char=.)
   This can be done using the following code:
   #+BEGIN_SRC C
int n = 123;
char c[20];
sprintf(c, "%d", n);
   #+END_SRC
2. Move the =ipos= pointer of the hashtable to the item given by the provided =qIndex= key.
   For this use the function =trx_hfind=
3. If item was found, get the index of =localHessians= out of the hashtable and save the corresponding entries in =localHessians= to =values=.
4. If not, set all entries of =values= to zero.
5. Return 0 or 1 accordingly.
**** DONE =double getLocalHessianComponent(struct Particle *p, unsigned int qIndex, unsigned int i, unsigned int j)=
     CLOSED: [2014-11-04 Tue 11:50]
The routine implements nearly the same functionality as =getLocalHessian()=. The only difference is that instead of the whole =NDIMMAT=-entries Hessian matrix only the (i+1),(j+1)-entry is returned.
Note that the indices are running from =0= to =NDIM-1=.
1. Convert =qIndex= into a =char= variable in order to find the right item in the hashtable. (The key in the hashtables are =unsigned char=.)
2. Move the =ipos= pointer of the hashtable to the item given by the provided =qIndex= key.
   For this use the function =trx_hfind=
3. If item was found, get the index of =localHessians= out of the hashtable and return the right entry of =localHessians=.
   Since the local Hessians are stored row-wise in =localHessians= (i.e. the first NDIM entries represent the first row, the next NDIM entries the second, etc.) the following formula can be used to get the right entries in =localHessians=:
   \((i,j) \mapsto NDIM*i + j\)
4. If not, return 0.0.
**** DONE =void cleanLocalHessians(Particle *p)=
     CLOSED: [2014-11-04 Tue 12:38]
The routine is supposed to reinitialize the data structures used in the =Particle= struct to store local Hessians, i.e. =localHessians= and =hessianIndex=.
For this the =localHessians= array is set to zero and the =hessianIndex= hashtable is cleaned, meaning that all items are destroyed.
1. Reinitialize the =localHessians= array with zeros using a simple for loop. The size of the array can be found in the =hessianIndex= stats.
2. The cleaning of the hashtable is done by the function =cleanHashTable()=.
**** DONE =void cleanHashTable(trx_htab *table)=
     CLOSED: [2014-11-04 Tue 12:52]
Routine should be called within cleanHessians(). The purpose is to mudulize cleanHessians such that the cleaning can be done easier in the future by changing cleanHashTable().
For the time being, the function iterates through the hashtable and deletes every item.
1. Set current position to the first item =if(trx_hfirst())=. Then loop over all items found in the hashtable using =while(hcount())=.
2. Free memory for the key =Free(trx_hkey())=.
3. Free memory for the value =Free(trx_hstuff())=.
4. Delete the item =trx_hdel()=. Note that this deletes the *current* item of the hashtable.
**** DONE =addLocalHessian(struct Particle *p, unsigned int qIndex, double *values)=
     CLOSED: [2014-11-04 Tue 15:59]
The routine looks in the =hessianIndex= hashtable for =qIndex=. If it is found the entries of =values= are added to the present ones. If =qIndex= is not yet in the hashtable a new entry is created.
If the =localHessians= array is running out of memory, it is reallocated.
1. Convert =qIndex= to an =unsigned char= variable using again the =sprintf= function.
   #+BEGIN_SRC C
int n = 123;
char c[20];
sprintf(c, "%d", n);
   #+END_SRC
2. Check if the hashkey is already taken in =hessianIndex=. For this use the function =trx_hadd()= which returns =FALSE= if the hashkey is already taken and sets the =ipos= pointer to the position of the hashkey. Use for the value-argument in =trx_hadd= a dummy value.
3. If =trx_hadd()= returns =TRUE=
   - check if more memory for the =localHessians= array has to be allocated. This can be done by comparing the number of items in the hashtable times =NDIMMAT= with =p->sizeOfLocalHessians=. If necessary reallocate the memory.
   - Then add =values= to the =localHessians= array and reset the stuff-value in the hashtable to the current index.
4. If =trx_hadd()= returns =FALSE= get index of the =localHessians= entry out of the hashtable and add the entries of =values= to the right =localHessians= entries.
**** DONE Test all routines.
     CLOSED: [2014-11-12 Wed 15:40]
     CLOCK: [2014-11-07 Fri 16:34]--[2014-11-07 Fri 19:06] =>  2:32
     CLOCK: [2014-11-07 Fri 11:36]--[2014-11-07 Fri 12:23] =>  0:47
     CLOCK: [2014-11-06 Thu 16:28]--[2014-11-06 Thu 17:32] =>  1:04
Implement some test functions for the routines. For this I use a seperate file [[file:~/tremolo/src/hessianTest/hessianTest.h]].
The testing code is run in the =Run()= routine in [[file:~/tremolo/src/tremolo.c]] (line 312).

***** The Particle list
In order to access the particles one can use the =Problem= struct in the following way: One uses the function =GetParticleById()= implemented in [[file:~/tremolo/src/idlist.c]] with the =IDs= list which is a member of the =Problem= struct.
: p = GetParticleById(P->IDs, id);

***** DONE Resolve Segmentation fault.
      CLOSED: [2014-11-11 Tue 17:39]
      CLOCK: [2014-11-11 Tue 15:26]--[2014-11-11 Tue 17:39] =>  2:13
Running tremolo, I get a segmentation fault while calling =addLocalHessians()=. This happens only after calling the function multiple times. =gdb= traces the segmentation fault back to the =trx_hash=-functions.
The error was a missing =*sizeof(double)= in =addLocalHessians()= when reallocating the memory for =localHessians=.

***** DONE Debug =test_addAndGetLocalHessians()=
      CLOSED: [2014-11-12 Wed 15:39]
      CLOCK: [2014-11-12 Wed 14:00]--[2014-11-12 Wed 15:38] =>  1:38
      CLOCK: [2014-11-12 Wed 10:14]--[2014-11-12 Wed 12:45] =>  2:31
      CLOCK: [2014-11-11 Tue 17:39]--[2014-11-11 Tue 19:03] =>  1:24
The getter methods do not work, see [[file:~/Sandbox/test/main.c][here]] for an example.
The problem was that I specified the wrong keylength as argument to =trx_hadd= and =trx_hfind=.

*** TODO Write Hessian calculation in lcforces.c [1/7]
    CLOCK: [2014-11-13 Thu 16:00]--[2014-11-13 Thu 17:26] =>  1:26
**** DONE Merge with branch testing
     CLOSED: [2014-11-13 Thu 17:02]
**** TODO Add data structures to particles
Add the creation and destruction of Hessian data structures to the functions which create Particles.
***** TODO Identify where the Particles are created
It seems  that the Particles are created in the =ReadParticles()= routine in [[file:~/tremolo/src/particle.c]] which is called by =InitSimBox()= which can be found in the same file. The =InitSimBox()= function is called in =Init()= (c.f. [[file:~/tremolo/src/init.c]]) which is itself called in the main program (=Run()= in [[file:~/tremolo/src/tremolo.c]]).
The creation itself is done in the =CreateParticleNoSpeStr()=.
**** TODO Write LCHessianList struct
This can be done in analogy to LCForceList.
Note that everything must be sorted according to the =r_cut=.
**** TODO Write registrationFunction for LCHessianList
This functions should add the right function pointer to the LCHessianList struct. It should work in analogy to the force registration.
**** TODO Add code that handles LCHessianList for Hessian computation
There must exist a function that activates the LCForceList. To this function some code that activates the LCHessianList struct must be added.
**** TODO Write Function that computes the Hessians in the case of the Lennard-Jones-Potential
This function does the actual force computation.

*** TODO Write extensive documentation about the Hessians
- [ ] How are they stored?
- [ ] Where and how are they computed?
- [ ] What data structures are used?

* Arbeitszeit
#+BEGIN: clocktable :maxlevel 3 :scope file :block thisweek
Clock summary at [2014-11-13 Thu 17:26], for week 2014-W46.

| Headline                                    | Time   |      |      |
|---------------------------------------------+--------+------+------|
| *Total time*                                | *9:12* |      |      |
|---------------------------------------------+--------+------+------|
| Aufgaben                                    | 9:12   |      |      |
| \__ TODO Add Hessians to tremolo            |        | 9:12 |      |
| \_____ DONE Füge Komfortfunktionen zu...    |        |      | 7:46 |
| \_____ TODO Write Hessian calculation in... |        |      | 1:26 |
#+END:

| Week     |      Time |  Overtime |
|----------+-----------+-----------|
| 2014-W20 |     10:32 |  01:32:00 |
| 2014-W21 |     09:08 |  00:08:00 |
| 2014-W22 |     12:55 |  03:55:00 |
| 2014-W23 |     10:49 |  01:49:00 |
| 2014-W24 |      7:41 | -01:19:00 |
| 2014-W25 |      8:01 | -00:59:00 |
| 2014-W26 |      5:21 | -03:39:00 |
| 2014-W27 |      5:43 | -03:17:00 |
| 2014-W28 |      4:33 | -04:27:00 |
| 2014-W29 |      0:23 | -08:37:00 |
| 2014-W30 |     11:18 |  02:18:00 |
| 2014-W31 |      8:48 | -00:12:00 |
| 2014-W32 |     11:48 |  02:48:00 |
| 2014-W33 |     11:04 |  02:04:00 |
| 2014-W34 |     15:04 |  06:04:00 |
| 2014-W35 |     11:23 |  02:23:00 |
| 2014-W37 |      6:00 | -03:00:00 |
| 2014-W38 |      8:09 | -00:51:00 |
| 2014-W39 |     12:13 |  03:13:00 |
| 2014-W40 |      5:00 | -04:00:00 |
| 2014-W41 |      9:02 |  00:02:00 |
| 2014-W42 |     13:08 |  04:08:00 |
| 2014-W43 |      9:00 |  00:00:00 |
| 2014-W44 |      9:17 |  00:17:00 |
| 2014-W45 |     11:24 |  02:24:00 |
| 2014-W46 |      9:12 | -01:14:00 |
|----------+-----------+-----------|
| Total    | 235:30:00 |  01:30:00 |
#+TBLFM: $3=$2-9*3600;T::@>$2=vsum(@2$2..@-1$2);T::@>$3=vsum(@2$3..@-1$3);T::
