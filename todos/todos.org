#+STARTUP: logdone
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper]

* Organization

** Commit conventions
1. Name branch I am working in.
2. Be explicit about what has been done.
3. Mark if a "project" is finished.


* Configurations


* Emacs

** Language evaluation in org mode (see http://zeekat.nl/articles/making-emacs-work-for-me.html#sec-10)
** DONE Qt Auto complete
   CLOSED: [2014-04-16 Wed 15:04]

** TODO Syntax highlighting for doxygen comments in c++ mode.

** TODO Setter and getter methods.

** TODO Rewrite Arbeitszeiten section


* Nuetzliches

** Konventionen für Tremolo Code (Kommentare, Coding Guidlines)
- Zum Einrücken immer nur 2 Leerzeichen verwenden. (Habe das bereits in Emacs geändert.)


** Tremolo und tremologui aktualisieren

Nachdem eine neue Version des Tremolo-Ordners gepullt wurde, kann Tremolo wie folgt aktualisiert werden:
: cd ~/tremolo/build
: make && make install

Das selbe gilt für Tremologui.
: cd ~/tremologui/build
: make && make install

In seltenen Fällen muss evtl. auch die CMake-Datei neu erzeugt werden: Dafür im build-Ordner:
: ccmake ..

Momentan sind die Pfadvariablen so eingestellt, dass die binaries in /home/huber/bin kopiert werden. Das kann man im ccmake Menu unter install_prefix ändern.


** Neue source und header Dateien in Tremolo einbinden
Dateien zunächst in [[file:~/tremolo/src]] einfügen, dann die Source-Datei in [[file:~/tremolo/CMakeLists.txt]] hinzufügen.


** Tremolo testen
Für self-tests von Tremolo kann das Programm runpybbt.py in [[~/tremolo/build/tests/]] verwendet werden.


** CTags in Emacs
In order to create the tags I ran the following command:
: find . -type f -iname "*.[xhS]" |xargs etags -a

In emacs ctags can be handled with the following commands:
- =M-. <RET>= :: Jump to the tag underneath the cursor.
- =M-. <tag> <RET>= :: Search for a particular tag.
- =C-u M-.= :: Find the next definition for the last tag.
- =M-*= :: Pop back where you previously invoked "M-.".



** Visualisieren von Tremolodaten
Dazu kann das Programm VMD verwendet werden: VMD visualisiert .xyz und .pdb Files:
: vmd *.xyz
Die graphische Anpassung kann in VMD unter Graphics->Representation angepasst werden.


** Gnuplot Befehle

Einen Ueberblick zu nuetzlichen Gnuplot Befehlen kann auf der folgenden Seite gefunden werden: http://people.duke.edu/~hpgavin/gnuplot.html

1. Um ein Data-file (zum Beispiel =*.epot*=) mit Gnuplot zu plotten, verwendet man: \\
   : gnuplot> plot "./argon.epot" using 1:2
   Hierbei wird die zweite Spalte gegen die erste Spalte aufgetragen.
2. Dies kann auch mit mehreren Files gleichzeitig getan werden: \\
   : gnuplot> plot "./argon.etot" using 1:2, "./argon.ekin" using 1:2, "./argon.epot" using 1:2
3. Um den Achsenabschnitt zu veraendern, verwendet man: \\
   : gnuplot> plot "./argon.epot" using 1:2; set yrange [-0.1: 2]
4. Den urspruenglichen Achsenabschnitt kann man wie folgt wieder herstellen: \\
   : gnuplot> plot "./argon.epot" using 1:2; set autoscale
5. Mit \\
   : gnuplot> replot
   kann der Plot aktualisiert werden.
6. Eine Uebersicht von =set= Befehlen:
   Create a title:
   : set title "Force-Deflection Data"
   Put a label on the x-axis:
   : set xlabel "Deflection (meters)"
   Put a label on the y-axis:
   : set ylabel "Force (kN)"
   Change the x-axis range:
   : set xrange [0.001:0.005]
   Change the y-axis range:
   : set yrange [20:500]
   Have Gnuplot determine ranges:
   : set autoscale
   Move the key:
   : set key 0.01,100
   Delete the key:
   : unset key
   Put a label on the plot:
   : set label "yield point" at 0.003, 260
   Remove all labels:
   : unset label
   Plot using log-axes:
   : set logscale
   Plot using log-axes on y-axis:
   : unset logscale; set logscale y
   Change the tic-marks:
   : set xtics (0.002,0.004,0.006,0.008)
   Return to the default tics:
   : unset xtics; set xtics auto
   Set output:
   : set output 'introduction.png'


** Grep Befehle

http://www.panix.com/~elflord/unix/grep.html


** Git Befehle

*** Branches
- Create a new branch:
  : git branch <name_of_new_branch>
- Create a new branch by pulling from a remote branch:
  : git checkout -b <name_of_new_branch> origin/<name_of_branch>
- Delete a local branch:
  : git branch -d <name_of_branch>
- Naming convention: use well defined tokes like
  : feature
  : bugfix
  : test
  followed by a slash '/' and a describing name, e.g.:
  : feature/potentials

*** Diff
- Show differences between <branch1> and <branch2>
  : git diff <branch1>..<branch2>

*** Manipulate changes.
- Remove untracked files:
  : git clean -f -d

*** Add and remove changes.
- Remove deleted files from stack:
  : git add -u .

*** Remote repositories
- Add remote repository with name /origin/ (e.g. https://pascalkimhuber@bitbucket.org/pascalkimhuber/stacked.git)
  : git remote add origin <address of remote>
- Push a local repository to a remote repository with name /origin/ for the first time
  : git push -u origin --all

*** Merging branches
- Merge <branch1> into <branch2>
  : git checkout <branch2>
  : git merge <branch1>


** Find Befehle

- Find all files with names containing =<pattern>= (wildcards have to be used with a preceeding backslash!):
  : find -name <pattern>
  or e.g.
  : find -name <pattern>\*


** Doxygen Befehle

- [[http://www.stack.nl/~dimitri/doxygen/manual/commands.html#cmdc][List of special commands]]


** GDB Befehle

*** Within GDB
Start the TUI (see source code and output)
: CTRL-x a
or just
: win


* Aufgaben

** TODO Add Hessians to tremolo
   CLOCK: [2014-10-15 Wed 16:14]--[2014-10-15 Wed 16:23] =>  0:09
   CLOCK: [2014-09-23 Tue 15:35]--[2014-09-23 Tue 17:23] =>  1:48
   - Note taken on [2014-10-01 Wed 15:00] \\
     Aufgabenbesprechung mit Christian am [2014-10-01 Wed 15:00]

     1. Grundaufgabe:
        - Füge Datenstrukturen für lokale Hesse-Matrizen und zugehörige particle-Matrix-Map (Hashmap) zum Particle-struct hinzu.
        - Die Berechnung der Hesse-Matrix sollte für das Lennard-Jones-Potential in CalcLCForceForParticle aus lcforces.c geschehen. Beachte dabei:
          + Flag-Abfrage: Hessian or noHessian?
          + Finde heraus was und wo die Registrierung der Kraftfunktion dabei ist.

     2. Anmerkungen:
        - hash-tables etc. finden sich in [[file:~/tremolo/src/hash/hashtab.h]]

     3. Sonstiges:
        - Vertragsverlängerung: Christian und ich haben jetzt erst einmal eine Vertragsverlängerung von 3 Monaten festgelegt. Wir warten jetzt zunächst die nächsten 2 Wochen zum endgültigen Entschluss ab.
*** Overview
**** Basics:
Consider a system of \(N\) particles \(p_1, ..., p_N\). Then a (simple) general potential \(V\) can be written as:
\[V(p_1, ..., p_N) = \sum_{i=1}^N \sum_{j = i+1}^N U_{i,j}(p_i, p_j),\]
where \(U_{i,j}\) is the pair potential between the particles \(i\) and \(j\).

**** Ideas:
1. It is enough to consider pair potentials for the Hessians:
\[ \partial_p \partial_q V = \partial_p \partial_q U_{p,q}, \]
\[ \partial_p \partial_p V = \partial_p \partial_p \sum_{q\neq p} U_{p,q}. \]
2. Storing of the Hessians.
   - Every particle stores an array of matrices with the name 'Hessians'
   - Every particle stores a map, which mpas particle indices to array indices of 'Hessians'.

**** Questions: [1/2]
1. [X] What are the access times for map-containers?
   /Ordered map: logarithmic in size. Unordered map: constant (average case), linear in size (worst case).
2. [ ] Which operations should be possible for the Hessians?

*** DONE Understand what potentials exist, how and where they are computed.
    CLOSED: [2014-10-01 Wed 15:05]
    CLOCK: [2014-10-01 Wed 09:00]--[2014-10-01 Wed 13:19] =>  4:19
    CLOCK: [2014-09-24 Wed 10:00]--[2014-09-24 Wed 12:45] =>  2:45
A summary can be found [[file:hessians.pdf][here. ]]

*** DONE Have a look at the hash-table implementation in tremolo and hash-map implementations in general [3/3]
    CLOSED: [2014-10-15 Wed 16:14]
    CLOCK: [2014-10-15 Wed 15:42]--[2014-10-15 Wed 16:14] =>  0:32
    CLOCK: [2014-10-15 Wed 14:25]--[2014-10-15 Wed 15:42] =>  1:17
    CLOCK: [2014-10-15 Wed 11:41]--[2014-10-15 Wed 12:49] =>  1:08
    CLOCK: [2014-10-15 Wed 11:00]--[2014-10-15 Wed 11:40] =>  0:40
    CLOCK: [2014-10-14 Tue 15:11]--[2014-10-14 Tue 16:00] =>  0:49
    CLOCK: [2014-10-13 Mon 17:00]--[2014-10-13 Mon 19:03] =>  2:03
    CLOCK: [2014-10-09 Thu 17:00]--[2014-10-09 Thu 19:02] =>  2:02
    CLOCK: [2014-10-08 Wed 13:45]--[2014-10-08 Wed 18:57] =>  5:12
    CLOCK: [2014-10-07 Tue 14:15]--[2014-10-07 Tue 16:03] =>  1:48

A description and an example showing the usage of the hash table can be found at [[http://burtleburtle.net/bob/hash/hashtab.html]]

**** DONE Have a close look at the code of Bob Jenkins and do all examples
     CLOSED: [2014-10-13 Mon 18:28]
The code can be found in [[file:~/Work/playground/hashtab/]].

**** DONE Try an example
     CLOSED: [2014-10-13 Mon 18:28]

**** DONE Look at code examples from tremolo
     CLOSED: [2014-10-15 Wed 14:25]
The trx_hcreate function is used in the following files (without hash-file):

huber@ram:~/tremolo/src$ grep -ri hashtab.h *
- bondforces.c:#include "hash/hashtab.h", bondforces.h:#include "hash/hashtab.h"
  Hier wird htab für BondTable, AngleTable, TorsionTable und ImporoperTable verwendet.
  Viele Code-Beispiele vorhanden.
- data.h:#include "hash/hashtab.h"
  Verwendung von trx_htab *ParticleNames in struct MoleculeParameter.
- lcforces.c:#include "hash/hashtab.h"
  Einbindung der Headerdatei hash/hashtab.h, ansonsten wird die Hash map nicht benutzt.
- parse.c:#include "hash/hashtab.h"
  Hier werden geparste Particle Names in den struct MoleculeParameter und preziser in trx_htab *ParticleNames hinzugefügt.
  Hier gibt es vielleicht ein paar kleine Code-Beispiele, wie ich die hash table Funktionen verwenden kann.
- reaxff.c:#include "hash/hashtab.h"
- SuCh.c:#include "hash/hashtab.h"
- tersoff.c:#include "hash/hashtab.h"

*** DONE Overview of Particle struct and force computation in tremolo.
    CLOSED: [2014-10-15 Wed 16:14]
    CLOCK: [2014-09-24 Wed 13:30]--[2014-09-24 Wed 14:30] =>  1:00

**** DONE Have a look at particle.c and particle.h
     CLOSED: [2014-10-15 Wed 16:14]
     CLOCK: [2014-10-01 Wed 14:25]--[2014-10-01 Wed 15:06] =>  0:41

**** TODO Have a look at the force computation in tremolo.

*** DONE Add data structures to Particle struct in data.h
    CLOSED: [2014-10-15 Wed 16:14]

*** DONE Write small testing case
    CLOSED: [2014-10-16 Thu 18:53]
    CLOCK: [2014-10-16 Thu 16:43]--[2014-10-16 Thu 18:53] =>  2:10
The example can be found in [[file:~/Sandbox/2ArgonMolecules]]
*** DONE Add Hessian Flag to tremolo [3/3]
    CLOSED: [2014-10-21 Tue 14:32]
    CLOCK: [2014-10-17 Fri 15:29]--[2014-10-17 Fri 16:07] =>  0:38
    CLOCK: [2014-10-17 Fri 13:40]--[2014-10-17 Fri 15:29] =>  1:49
    CLOCK: [2014-10-17 Fri 10:37]--[2014-10-17 Fri 12:30] =>  1:53
**** DONE Add a Flag "computeHessians" into the Problem struct.
     CLOSED: [2014-10-17 Fri 15:58]
**** DONE Add a keyword to the tremolo parameter file. [2/2]
     CLOSED: [2014-10-17 Fri 16:01]
- [X] Change parameter file.
- [X] Change documentation (such that the flag is included)
**** DONE Add option to the parser routines. [2/2]
     CLOSED: [2014-10-21 Tue 13:35]
     CLOCK: [2014-10-21 Tue 11:10]--[2014-10-21 Tue 14:35] =>  3:25
- [X] Function StoreAnalyzeHessians in groupmeas.c has to be changed such that the hessian-flag in the Problem struct is changed.
- [X] Ask Christian about install process for tremolo. Get error if I try make install...
*** DONE Füge Komfortfunktionen zu particle.c hinzu [8/8]
    CLOSED: [2014-11-13 Thu 16:00]
    CLOCK: [2014-11-05 Wed 15:54]--[2014-11-05 Wed 18:15] =>  2:21
    CLOCK: [2014-11-04 Tue 14:16]--[2014-11-04 Tue 16:04] =>  1:48
    CLOCK: [2014-11-04 Tue 12:32]--[2014-11-04 Tue 12:52] =>  0:20
    CLOCK: [2014-11-04 Tue 10:00]--[2014-11-04 Tue 12:32] =>  2:32
    CLOCK: [2014-10-30 Thu 16:53]--[2014-10-30 Thu 17:52] =>  0:59
    CLOCK: [2014-10-29 Wed 10:00]--[2014-10-29 Wed 12:51] =>  2:51
    CLOCK: [2014-10-28 Tue 13:35]--[2014-10-28 Tue 15:31] =>  1:56
    CLOCK: [2014-10-28 Tue 08:30]--[2014-10-28 Tue 12:01] =>  3:31
    - Note taken on [2014-10-29 Wed 12:21] \\
      Note that the hashkey length used in the Hessian hashtable in the particle struct is defined in [[file:~/tremolo/src/particle.c]].
      #+BEGIN_SRC C
      #define HASH_KEYLEN 32
      #+END_SRC
**** DONE =void *createLocalHessians(struct Particle *p, int numberOfHessians)=
     CLOSED: [2014-10-29 Wed 11:50]
The routine should be called whenever a new Particle struct is created, but only if the flat =computeHessians= in the Problem struct is set to 1.
1. Allocate memory for a double array of size =NDIMMAT x numberOfNeighbors=
   and assign it to the =localHessians= pointer of =p=. The number of entries is stored to =p->sizeOfLocalHessians=.
   - In order to initialize the array with zeros use =Calloc= for memory allocation.
2. Create a =trx_htab= of size greater than =numberOfNeighbors= and assign it to the =hessianIndex= pointer of =p=.
   - Since the size of the hashtable is given by 2^(logsize) first the binary logarithm of =numberOfNeighbors= must be calculated.
   - In order that the hashtable is large enough the final logsize is given by =log2(numberOfNeighbors)+2=.

**** DONE =void destroyParticleHessians(struct Particle *p)=
     CLOSED: [2014-10-29 Wed 12:08]
The routine should be called whenever a Particle struct is destroyed and memory for Hessians was allocated.
1. Free all memory of the =localHessians= array. For this the customized =Free= routine in =util.h= is used.
2. Destroy =hessianIndex= hashtable and free all its memory.
   - Before destroying the hashtabe itself all items have to be deleted and freed in a while loop.
   - After that the hashtable can be destroyed using =trx_hdestroy()=.
**** DONE =int getLocalHessian(struct Particle *p, unsigned int qIndex, double *values)=
     CLOSED: [2014-11-04 Tue 11:22]
The routine is supposed to get all =NDIMMAT= entries of the local Hessian \(\partial_p \partial_qIndex V\) and store them in =values=. If =qIndex= is not found in the =hessianIndex= hashtable an zero-array is stored in =values= and in this case the routine returns 0. In all other cases it returns 1.
Note that the caller has to make sure that =values= is large enough (size =NDIMMAT=).
1. Convert =qIndex= into a =unsigned char= variable in order to find the right item in the hashtable. (The key in the hashtables are =unsigned char=.)
   This can be done using the following code:
   #+BEGIN_SRC C
int n = 123;
char c[20];
sprintf(c, "%d", n);
   #+END_SRC
2. Move the =ipos= pointer of the hashtable to the item given by the provided =qIndex= key.
   For this use the function =trx_hfind=
3. If item was found, get the index of =localHessians= out of the hashtable and save the corresponding entries in =localHessians= to =values=.
4. If not, set all entries of =values= to zero.
5. Return 0 or 1 accordingly.
**** DONE =double getLocalHessianComponent(struct Particle *p, unsigned int qIndex, unsigned int i, unsigned int j)=
     CLOSED: [2014-11-04 Tue 11:50]
The routine implements nearly the same functionality as =getLocalHessian()=. The only difference is that instead of the whole =NDIMMAT=-entries Hessian matrix only the (i+1),(j+1)-entry is returned.
Note that the indices are running from =0= to =NDIM-1=.
1. Convert =qIndex= into a =char= variable in order to find the right item in the hashtable. (The key in the hashtables are =unsigned char=.)
2. Move the =ipos= pointer of the hashtable to the item given by the provided =qIndex= key.
   For this use the function =trx_hfind=
3. If item was found, get the index of =localHessians= out of the hashtable and return the right entry of =localHessians=.
   Since the local Hessians are stored row-wise in =localHessians= (i.e. the first NDIM entries represent the first row, the next NDIM entries the second, etc.) the following formula can be used to get the right entries in =localHessians=:
   \((i,j) \mapsto NDIM*i + j\)
4. If not, return 0.0.
**** DONE =void cleanLocalHessians(Particle *p)=
     CLOSED: [2014-11-04 Tue 12:38]
The routine is supposed to reinitialize the data structures used in the =Particle= struct to store local Hessians, i.e. =localHessians= and =hessianIndex=.
For this the =localHessians= array is set to zero and the =hessianIndex= hashtable is cleaned, meaning that all items are destroyed.
1. Reinitialize the =localHessians= array with zeros using a simple for loop. The size of the array can be found in the =hessianIndex= stats.
2. The cleaning of the hashtable is done by the function =cleanHashTable()=.
**** DONE =void cleanHashTable(trx_htab *table)=
     CLOSED: [2014-11-04 Tue 12:52]
Routine should be called within cleanHessians(). The purpose is to mudulize cleanHessians such that the cleaning can be done easier in the future by changing cleanHashTable().
For the time being, the function iterates through the hashtable and deletes every item.
1. Set current position to the first item =if(trx_hfirst())=. Then loop over all items found in the hashtable using =while(hcount())=.
2. Free memory for the key =Free(trx_hkey())=.
3. Free memory for the value =Free(trx_hstuff())=.
4. Delete the item =trx_hdel()=. Note that this deletes the *current* item of the hashtable.
**** DONE =addLocalHessian(struct Particle *p, unsigned int qIndex, double *values)=
     CLOSED: [2014-11-04 Tue 15:59]
The routine looks in the =hessianIndex= hashtable for =qIndex=. If it is found the entries of =values= are added to the present ones. If =qIndex= is not yet in the hashtable a new entry is created.
If the =localHessians= array is running out of memory, it is reallocated.
1. Convert =qIndex= to an =unsigned char= variable using again the =sprintf= function.
   #+BEGIN_SRC C
int n = 123;
char c[20];
sprintf(c, "%d", n);
   #+END_SRC
2. Check if the hashkey is already taken in =hessianIndex=. For this use the function =trx_hadd()= which returns =FALSE= if the hashkey is already taken and sets the =ipos= pointer to the position of the hashkey. Use for the value-argument in =trx_hadd= a dummy value.
3. If =trx_hadd()= returns =TRUE=
   - check if more memory for the =localHessians= array has to be allocated. This can be done by comparing the number of items in the hashtable times =NDIMMAT= with =p->sizeOfLocalHessians=. If necessary reallocate the memory.
   - Then add =values= to the =localHessians= array and reset the stuff-value in the hashtable to the current index.
4. If =trx_hadd()= returns =FALSE= get index of the =localHessians= entry out of the hashtable and add the entries of =values= to the right =localHessians= entries.
**** DONE Test all routines.
     CLOSED: [2014-11-12 Wed 15:40]
     CLOCK: [2014-11-07 Fri 16:34]--[2014-11-07 Fri 19:06] =>  2:32
     CLOCK: [2014-11-07 Fri 11:36]--[2014-11-07 Fri 12:23] =>  0:47
     CLOCK: [2014-11-06 Thu 16:28]--[2014-11-06 Thu 17:32] =>  1:04
Implement some test functions for the routines. For this I use a seperate file [[file:~/tremolo/src/hessianTest/hessianTest.h]].
The testing code is run in the =Run()= routine in [[file:~/tremolo/src/tremolo.c]] (line 312).

***** The Particle list
In order to access the particles one can use the =Problem= struct in the following way: One uses the function =GetParticleById()= implemented in [[file:~/tremolo/src/idlist.c]] with the =IDs= list which is a member of the =Problem= struct.
: p = GetParticleById(P->IDs, id);

***** DONE Resolve Segmentation fault.
      CLOSED: [2014-11-11 Tue 17:39]
      CLOCK: [2014-11-11 Tue 15:26]--[2014-11-11 Tue 17:39] =>  2:13
Running tremolo, I get a segmentation fault while calling =addLocalHessians()=. This happens only after calling the function multiple times. =gdb= traces the segmentation fault back to the =trx_hash=-functions.
The error was a missing =*sizeof(double)= in =addLocalHessians()= when reallocating the memory for =localHessians=.

***** DONE Debug =test_addAndGetLocalHessians()=
      CLOSED: [2014-11-12 Wed 15:39]
      CLOCK: [2014-11-12 Wed 14:00]--[2014-11-12 Wed 15:38] =>  1:38
      CLOCK: [2014-11-12 Wed 10:14]--[2014-11-12 Wed 12:45] =>  2:31
      CLOCK: [2014-11-11 Tue 17:39]--[2014-11-11 Tue 19:03] =>  1:24
The getter methods do not work, see [[file:~/Sandbox/test/main.c][here]] for an example.
The problem was that I specified the wrong keylength as argument to =trx_hadd= and =trx_hfind=.

*** TODO Write Hessian calculation in lcforces.c [7/11]
    CLOCK: [2014-11-13 Thu 16:00]--[2014-11-13 Thu 17:26] =>  1:26
**** DONE Merge with branch testing
     CLOSED: [2014-11-13 Thu 17:02]
**** DONE Add data structures to particles
     CLOSED: [2014-11-18 Tue 17:24]
     CLOCK: [2014-11-18 Tue 17:12]--[2014-11-18 Tue 17:24] =>  0:12
     CLOCK: [2014-11-18 Tue 15:30]--[2014-11-18 Tue 17:12] =>  1:42
Add the creation and destruction of Hessian data structures to the functions which create Particles.
***** DONE Identify where the Particles are created
      CLOSED: [2014-11-18 Tue 17:13]
It seems  that the Particles are created in the =ReadParticles()= routine in [[file:~/tremolo/src/particle.c]] which is called by =InitSimBox()= which can be found in the same file. The =InitSimBox()= function is called in =Init()= (c.f. [[file:~/tremolo/src/init.c]]) which is itself called in the main program (=Run()= in [[file:~/tremolo/src/tremolo.c]]).
The creation itself is done in the =CreateParticleNoSpeStr()=.
***** DONE Add creation of localHessians to Particle-creation.
      CLOSED: [2014-11-18 Tue 17:14]
This is done in =CreateParticleNoSpeStr=.
***** DONE Add destruction of localHessians to Particles.
      CLOSED: [2014-11-18 Tue 17:24]
This is done in =DeleteParticle()= in [[file:~/tremolo/src/particle.c]].
**** DONE Make a Plan for the next steps
     CLOSED: [2014-11-26 Wed 17:22]
     - Note taken on [2014-11-21 Fri 19:39] \\
       Aufgabenbesprechung mit Christian am [2014-11-21 Fri 18:00]
       
       1. Register Hessian functions, at the same position where the potentials are registered (indenpendently of the flag)
       2. Check if flag is set and in that case delete registered Hessian functions. This can be done either in ControlOutputRecord, StoreOutput)
       3. It is enough to implement LCHessList structs. These are then implemented as members of the LCForceData struct and can use their data.
       
       TODOs: 
       - Mache einen Plan aus den folgenden TODOs ;)
       - Prüfe, was Jan ins redmine gepusht hat
       - Setze Hessian Flag in den Output-Block
       - Finde heraus, wo die Registrierung der Hessian Funktion stattfinden kann. Beachte, dass dies auch abhängig davon ist, welche Potential verwendet werden.
       - Implementiere struct LCHessianList
       - Implementiere RegisterLCHessian Funktion in Analogie zu RegisterLCPotential
       - Implementiere Hessian computation für das Lennard-Jones Potential
       - Implementiere Funktion, die die Ausführung der Hessian computation auslöst (in Analogie zur Kraftberechnung)
       - Bespreche mit Christian den Output der Ergebnisse

**** DONE Implement registration for Hessian computation
***** Summary
- lcforces ::
  - added =struct LCHessianList= to =LCForceData=
  - implemented 
    #+BEGIN_SRC c
      int RegisterLCHessian(struct Problem * P, struct LCForceParams * LFP, LCHessianFunction * HFcn, int ParType1, intParType2, double r_cut, void * data)
    #+END_SRC
    which register Hessian functions
  - changes in =InitLCForceParams()=: initialize empty (but NULL-terminated) HList array
  - changes in =DeleteLCForceParams()=: delete HList arrays
  - added typedefs for Hessian related function pointers: 
    #+BEGIN_SRC c
      typedef double LCHessianFunction(void *data)
      typedef void LCRemoveHessianDataFcn(void *data)
    #+END_SRC
- groupmeas ::
  - changes in =StoreAnalyzeHessians()=:remove all LCHessianList structs if compute-Hessian flag is set to "no"
***** DONE Write the registration-function for LCHessianList
     CLOSED: [2014-12-12 Fri 11:04]
     CLOCK: [2014-12-05 Fri 16:14]--[2014-12-05 Fri 17:20] =>  1:06
     CLOCK: [2014-12-05 Fri 14:15]--[2014-12-05 Fri 16:14] =>  1:59
     CLOCK: [2014-12-05 Fri 11:00]--[2014-12-05 Fri 12:30] =>  1:30
     CLOCK: [2014-12-04 Thu 16:45]--[2014-12-04 Thu 18:08] =>  1:23
     CLOCK: [2014-12-04 Thu 10:00]--[2014-12-04 Thu 13:00] =>  3:00
     CLOCK: [2014-12-03 Wed 15:30]--[2014-12-03 Wed 17:30] =>  2:00
     CLOCK: [2014-11-26 Wed 17:20]--[2014-11-26 Wed 18:22] =>  1:02
     CLOCK: [2014-11-26 Wed 10:40]--[2014-11-26 Wed 13:20] =>  2:40
This functions should add the right function pointer to the LCHessianList struct. It should work in analogy to the force registration.
****** DONE Determine where to put the registration of the Hessian computation functions. 
       CLOSED: [2014-11-26 Wed 17:20]
       CLOCK: [2014-11-26 Wed 14:20]--[2014-11-26 Wed 18:22] =>  4:02
      CLOCK: [2014-11-26 Wed 10:10]--[2014-11-26 Wed 10:40] =>  0:30
      CLOCK: [2014-11-21 Fri 16:00]--[2014-11-21 Fri 19:48] =>  3:48
      CLOCK: [2014-11-21 Fri 09:31]--[2014-11-21 Fri 12:30] =>  2:59
      CLOCK: [2014-11-18 Tue 17:31]--[2014-11-18 Tue 17:53] =>  0:22
******* Summary: 
The idea is to register the Hessian computation functions at the same location where already the potentials are registered, no matter if the Hessian-flag is set or not. And then check if the flag is set at a later time (=ControlOutputRecord()= or =StoreOutput=) and either leave the functions registered or delete them. 
******** Location for the registration of Hessian-computation functions
Implement the function 
: registerLCHessian(P, /*arguments?*/)
in the =StoreLennardJonesData()= function. 
******** Location for the possible deletion of the Hessian-computation registration 
Delete the registration of Hessian-computation functions if flag =P->computeHessians= is set to zero in the function 
: StoreAnalyzeHessians(struct Problem P, FilePosType filePos, parse_data pd)
******* Details
******** Overview to potential registration
         - Note taken on [2014-11-26 Wed 11:01] \\
           Note about potential registration
           
           1. =LCForceParams struct= 
              - =LFPArray= :: In the =LCStructData= there exists a struct =LCForceParams= named =*LFPArray[MaxLCForceParamType]= which is an array of force parameters for different /stages/ of forces (length: =MaxLCForceParamType=). 
                This is array is apparently initialized in the functions 
                - =ReadParametes()=
                - =InitLCForces()=
                - and some parsing routines
                It is destroyed in =DeleteLCForces=. 
                The array is used in the functions
                - =GetLCEnergy()=
                - =SetLCEnergy()=
                - =MainLCForce()=
              - =LFPAddArray= :: This is an additional array of =LCForceParams= for additional force parameters (cf. brenner.c, bornitrit.c, stiwe.c, tersof.c, reaxff.c). The length of the array is given by =MaxLFPAddArray= stored in =LCStructData=
              - LFPMeasArrayA,B,C :: These are again arrays of =LCForceParams= all of length =MaxLCMeasParamType= which is currently set to 9. These data structures are apparently used to register functions for measurements? 
           2. Force stages
              The number of /force stages/ is defined by the Macro =MaxLCForceParamType= which is currently set to 6 (cf. [[file:~/tremolo/src/data.h::813]]) 
              The stages are given by: 
              - Stage 1 :: Lennard Jones type, use symmetry
              - Stage 2 :: Sutton Chen/Brenner type
              - Stage 3 :: Brenner
              - Stage 4 :: BN type, ReaxFF
              - Stage n-1 :: Sending of summed up forces
              - Stage n :: :: Extract measurements
              The stages correspond to the different entries of the =LFPArray= in =LCStructData=. They are called (and described) in =MainLCForce()=. There exists also a enum =LCForceParamType= in [[file:~/tremolo/src/data.h::815]].
           3. Potential registration
              - =ReadParameters()= :: Here =LFPArray=, =LFPAddArray= are initialized with =NULL=.
                - =ParsePotentialFiles(P)= :: This function is called in =ReadParameters()=. It registers the parsing functions and do also the parsing steps for the registered functions. In detail: 
                  1. =ParsePotentialFiles(P)= registers parsing functions using =register_parse_store_func1()=, e.g. =Read2BodyPotentials=.
                  2. Then the parsing is done by calling =parse_file_name_suffix= which calls =parse_file= which calls =store_parsevals()=. Here all previously registered functions in the corresponding =keyword_jump_table= are called.
                  3. In the case of =Read2BodyPotentials=, a switch-construction calls different two-body potentials "read-functions", e.g. =ReadLennardJonesData()=.
                  4. This function calls a "store-function": =StoreLennardJonesData()=.
                  5. This function calls first =InitLCForceParams()= and then =RegisterLCPotential()= which does the actual potential registration. 
                  6. In =RegisterLCPotential()= the given function pointer is registered. 
                - =RegisterAllFinalize(P)= :: Here similary to =ParsePotentialFiles()= other potentials are registered. 
              - =InitLCForces()= :: This function is called only once in the main function =Run()=. Here =UpdateLCForces()= is called (something with update offsets ??) and it is checked if the potentials are threadsafe. 
         
******** Summary about potential registration
1. Global registration process for potentials (only for =ParsePontentialFiles()= - similary for =RegisterAllFinalize()=): 
   - =main()=
     - =Run()=
       - =ReadParameters()=
         - =ParsePotentialFiles()=
           - registers parsing functions (e.g. =register_parse_store_func1(P, LC_KEY(nonbonded_2body_potentials), Read2BodyPotentials)=): 
         - executes file parsing for the file with given suffix: =parse_file_name_suffix()= 
           - =parse_file()=
             - =store_parsevals()=: calls all registered functions in the corresponding =keyword_jump_table=
2. Actual registration (potential dependent), e.g. =Read2BodyPotentials()=: 
   - =Read2BodyPotentials()= Is called for an explicit pair of particletypes. 
     Switch-case construction for choice of right force type.
     - =ReadLennardJonesData()=
       - =StoreLennardJonesData()=
         - =InitLCForceParams()=
         - =RegisterLCPotential()=: =RegisterLCPotential(P, LFP, CalcLennardJonesSplineForce, FreeLennardJonesSplineData, SetLennardJonesSplineEnergy, GetLennardJonesSplineEnergy, ParType1, ParType0, r_cut, data, 1, 1, LCPairRun)=
******** Location of the Hessian registration 
It is possible to registrate the Hessian computation function just together with the registration of the potential. 

******** Parsing of the =output= block in the =.parameters=-file
1. Registration of the parameter-file parsing functions: 
   - =main()=
     - =Run()=
       - =ReadParameters()=
         - =SetDefaultParseParameterFiles()= calls =ParmInit[i].SetDefaultFn(P)= multiple times, which results in calling =SetDefaultOutputRecord(P)= 
           - =register_parse_store_func1(..., StoreOutput)=
2. Functioning of the =StoreOutput= function 
   - =StoreOutput(P, filePos, pd)=
     - =StoreOutputAnalyze(P, filePos, pd)=
       - =StoreAnalyzeHessians()= sets the =computeHessians= flag in the =Problem= struct.
3. Parsing of the parameter file and the =output= block
   - =main()=
     - =Run()=
       - =ReadParameters()=
         - =ParseParameterFiles(P)=
           - =parse_file_name_suffix= which is called for the suffix =parameterfile= which then parses the =.parameters=-file. 
******** Location of the Hessian registration checkup function 
Since the =potentials= file is parsed before the =parameters= file, the strategy to registrate the right compute-Hessian functions is first to registrate all possible compute Hessian functions and then in a second step to delete all compute-Hessian functions that are not used. 
****** DONE Determine which data structures are actually needed for the registration and the computation 
       CLOSED: [2014-12-04 Thu 16:47]
       CLOCK: [2014-11-26 Wed 18:23]--[2014-11-26 Wed 18:30] =>  0:07
******* Description of =RegisterLCPotential()=
1. set max_r_cut, max_r_cut_2 in LFP->MaxForceData.
2. Some error checking.
3. Insert ForceFunction in the right =Flist=
   1. set r_cut_2
   2. set needNorm
   3. set Flist to =LFP->ForceData.Flist=
   4. Find correct insert index for the LcForceList-struct
   5. Reallocate memory for the list
   6. Allocate memory for the new LCForceList-struct and set values. 
****** DONE Implement LCHessianList struct
       CLOSED: [2014-12-04 Thu 12:33]
This can be done in analogy to LCForceList.
It is conceived as a member of the =LCForceData=-struct
Note that everything must be sorted according to the =r_cut=.
#+BEGIN_SRC c
struct LCHessianList 
{
  double r_cut_2; // r_cut^2 used for calculation
  LCHessianFunction *HessianFunction; // pointer to the function which computes the Hessian
  void *data; // pointer to a data struct which stores data used for the computation
  // LCRemovePotDataFcn *RemovePotDataFunction; // pointer to the function which frees the memory of the data struct. (necessary?)
}
#+END_SRC
The =LCRemovePotDataFcn= may be unnecessary since it is already included in the =LCForceList= struct. This function is called at the very end of the simulation in =RemoveEverything()=. So it is rather unnecessary to insert the function as member. 
****** DONE Implement function =registerLCHessian()=
      CLOSED: [2014-12-04 Thu 16:47]
This is done in analogy to =RegisterLCPotential()=. 
#+BEGIN_SRC c
  int registerLCHessian(struct Problem *P, 
                        struct LCForceParams *LFP, 
                        LCHessianFunction *HFcn, 
                        int ParType1, 
                        int ParType2, 
                        double r_cut, 
                        void *data)
  {
          int insertIndex, int index, int maxIndex;        // Helper variables for indexing. 
          double r_cut_2;                                  // r_cut squared.  
          struct LCHessianList **HList;                    // Temp pointer for a LCHessianList array. 
          
          // Do consistency check for r_cut. 
          if (r_cut <= 0.0)
                  return 0; 
  
          // Compute r_cut squared. 
          r_cut_2 = r_cut * r_cut; 
  
          // Assign LCHessianList-array for the given particle types to the temporary pointer. 
          HList = LFP->ForceData[ParType1*LFP->MaxParType + ParType2].HList;
  
          // Get correct entry in the HList (the array is sorted by decreasing r_cut). 
          insert = -1; 
          for (index = 0; HList[index] != NULL; ++index)
          {
                  if (HList[index]->r_cut_2 < r_cut_2 && insertIndex == -1)
                          insertIndex = index; 
          }
          if (insertIndex == -1)
                  insertIndex = index; 
  
          // Set maxIndex; 
          maxIndex = index; 
  
          // Reallocate memory for one more LCHessianList-struct in the array. 
          HList = Realloc(HList, (maxIndex + 2)*sizeof **HList, 
                          "registerLCHessian(): Reallocate memory");
  
          // Replace the LCHessianList with the reallocated one. 
          LFP->ForceData[ParType1*LFP->MaxParType + ParType2].HList = HList; 
  
          // Get the right position in the LCHessianList array for the new struct. 
          for (index = maxIndex + 1; index > insertIndex; index--)
          {
                  HList[index] = HList[index - 1]; 
          }
  
          // Allocate memory and set all data of the new LCHessianList struct.
          HList[insertIndex] = Malloc(sizeoff **HList, 
                                      "registerLCHessian(): Allocate memory"); 
          HList[insertIndex]->r_cut_2 = r_cut_2; 
          HList[insertIndex]->data = data; 
          HList[insertIndex]->HessianFunction = HFcn; 
  
          return 0; 
  }
#+END_SRC
****** DONE Initialization of LCHessianList
      CLOSED: [2014-12-04 Thu 17:01]
The initialization of the =LCForceList= is done in =InitLCForceParams=. Note that this has to be done since the array is defined as =NULL= terminated array. 
For the =LCHessianList= initialization add the following lines to =InitLCForceParams= [[file:~/tremolo/src/lcforces.c::442]]: 
#+BEGIN_SRC c
LFP->ForceData[ij].HList = Malloc(sizeof(struct LCHessianList *), "InitLCForceParams"); 
LFP->ForceData[ij].HList[0] = NULL; 
#+END_SRC
****** DONE Free memory for the LCHessianList array. 
      CLOSED: [2014-12-04 Thu 18:00]
For the =LCForceList= structs the memory is freed in the function =DeleteLCForceParams()=. In order to handle the =LCHessianList= add the following to [[file:~/tremolo/src/lcforces.c::664]]:
#+BEGIN_SRC c
  HList = LFP->ForceData[ij].HList; 
  for (m = 0; HList[m] != NULL; ++m)
  {
          Free (HList[m]); 
  }
  Free(LFP->ForceData[ij].HList); 
#+END_SRC
****** DONE Check if Hessians are computed
      CLOSED: [2014-12-05 Fri 12:34]
Since the =output= block is parsed after the registration of the potentials, it is necessary to check if Hessians have to be computed. If not the =LCHessianList= array must be emptied. This can be done in the =StoreAnalyzeHessians()= function: 
#+BEGIN_SRC c
  int StoreAnalyzeHessians(struct Problem *P, FilePosType *filePos, parse_data *pd)
  {
          // If "hessians: measure = on" set the flag in P to 1.
          if (parse_on_off(filePos, pd)) {
                  P->computeHessians = 1;
          }
          // Otherwise set the flag in P to 0 and clean LCHessianList array.
          else {
                  // Set flag in P to 0. 
                  P->computeHessians = 0;
  
                  // Empty LCHessianList array. 
                  for (stage = 0; stage < MaxLCForceParamType; ++stage)
                  {
                          if (&P->LCS.LFPArray[stage] != NULL)
                          {
                                  for(i = 0; i < MaxParType; ++i)
                                  {
                                          for(j = 0; j < MaxParType; ++j)
                                          {
                                                  ij = i * MaxParType + j;
                                                  HList = LFP->ForceData[ij].HList; 
                                                  for(m = 0; HList[m] != NULL; ++m)
                                                  {
                                                          // Note that the data member of HList[m] is not freed, since it is used by the LCForceList struct. 
                                                          Free[HList[m]];
                                                  }
                                                  // Add NULL entry to the array (since it is defined as NULL terminated array.)
                                                  HList = Malloc(sizeof(HList*), "StoreAnalyzeHessians: Allocate memory."); 
                                                  HList[0] = NULL; 
                                          }
                                  }
                          }
                  }
          }
          
          // Return without error.
          return 0;
  }
#+END_SRC
**** DONE Add code that handles LCHessianList for Hessian computation
     CLOSED: [2014-12-12 Fri 17:29]
     CLOCK: [2014-12-12 Fri 16:38]--[2014-12-12 Fri 17:29] =>  0:51
     CLOCK: [2014-12-12 Fri 15:57]--[2014-12-12 Fri 16:38] =>  0:41
     CLOCK: [2014-12-12 Fri 10:50]--[2014-12-12 Fri 12:21] =>  1:31
     CLOCK: [2014-12-12 Fri 10:00]--[2014-12-12 Fri 10:49] =>  0:49
There must exist a function that activates the LCForceList. To this function some code that activates the LCHessianList struct must be added.
***** DONE Overview to force calculation in tremolo
      CLOSED: [2014-12-12 Fri 15:58]
- =MainLCForce=
  This functions activates the different stages of potentials and calls for every stage the functions
  - =CalcLCForce()= :: Iterates over all cells and calculates the force in these cells.  
  - =CalcLCMeasure()= :: Iterates over all cells, call =CalcLCMeasureForParticle()= which calls the functions stored by the =LFPMeasArray= s. 
  - =ForceCom()= :: Force communication. 
- =CalcLCForce()= 
  This functions iterates over all cells and calls =CalcLCForceForCell()= which calculates the forces in that cell. 
  The function receives the arguments
  - P :: Problem struct
  - LCS->LFPArray[LCForceParamA] :: The =LCForceParams= struct for the given stage (in this case LCForceParamA - stage).
  - LCS :: LinkedCell data struct
  - n :: Number of the cell
- =CalcLCForceForCell()= 
  This function iterates over all particles in the given cell and calls
  - =CalcLCForceSingleParticle()= :: Computes all single potential forces.
  - =CalcLCForceForParticle()= :: Computes all pair potential contributions. 
- =CalcLCForceForParticle()=
***** DONE Determine interface for the LCHessianFunction function pointer. 
      CLOSED: [2014-12-12 Fri 17:12]
The typedef for the function pointer is in [[file:~/tremolo/src/lcforces.h::62]] and must be changed accordingly. 
***** DONE Determine where the actual computation of the Hessians should take place 
      CLOSED: [2014-12-12 Fri 17:29]
Write the Hessiancalculation in a function that is called in =CalcLCForceForParticle()= (after the if (Fnorm !=0.0) block). 
Note that every pair of particles is touched only once!!!
In detail: 
In =CalcLCForceForParticle()= the =HList= is supposed to be iterated after line 692. Then for every =HList=-entry the Hessian-computation function is called.  
This function (which comes from the potential) is supposed to do the rest of the work: compute the 4 Hessians (pp, pq, qp, qq) and add these to the particles. 
**** DONE Write Function that computes the Hessians in the case of the Lennard-Jones-Potential
     CLOSED: [2014-12-14 Sun 19:55]
     CLOCK: [2014-12-14 Sun 16:35]--[2014-12-14 Sun 19:55] =>  3:20
This function does the actual force computation.
***** DONE Determine what data is needed for the computation
      CLOSED: [2014-12-14 Sun 19:55]
**** DONE Add function call of Lennard-Jones Hessian computation to tremolo.
     CLOSED: [2014-12-19 Fri 11:38]
     CLOCK: [2014-12-18 Thu 11:00]--[2014-12-18 Thu 11:18] =>  0:18
Whenever the flag is set to compute and the Lennard-Jones Potential is selected the function must be called. 
This should be done by registering the hessican computation function in =StoreLennardJonesData()=: use =registerLCHessian=. 
Note that for this a data-struct must be created etc. This should be done by a deep copy(!). 
**** TODO Ask Christian about bonddist in Lennard-Jones Hessian computation. 
**** TODO Do some testing. 
     CLOCK: [2014-12-22 Mon 16:15]
Note that no reinitialization is implemented yet. 
For the 2-particle case the calculation seemst to be correct. 
***** TODO Find examples in the papers and test them with tremolo. 
The papers can be found [[file:hessians][here]]. 
**** TODO Implement Hessian output and reinitialization
Output format: 
Id_1, coord_1, Id_2, coord_2, value
***** TODO Determine where the output should take place
**** TODO Use symmetries to reduce storage amount
*** TODO Write extensive documentation about the Hessians
- [ ] How are they stored?
- [ ] Where and how are they computed?
- [ ] What data structures are used?


* Fragen 
- [ ] Was macht =static int UpdateOffsetsLCForceParams(struct Problem *P, struct LCForceParams *LFP, int MaxShell[NDIM])=? Wird von =void UpdateLCForces(struct Problem *P, struct LCStructData *LCS)= (mehrmals!) aufgerufen.
- [ ] Warum wird in der =int StoreLennardJonesData(struct Problem *P, int ParType0, int ParType1, double r_cut)= Funktion die Registrierung noch einmal aufgerufen, wenn der erste und der zweite Parametertype nicht gleich sind?
- [ ] Was ist =needNorm= im =LCForceData= struct? 
- [ ] Was unterscheided =RegisterLCPotential= und =RegisterLCPotentialOnce= voneinander?
- [ ] Muss ich auch den Code für =MainCoulombForce()= und =BondedForces()= ändern?
- [ ] Was macht =RETURN_ON_PYMOLO_ERROR()=?


* Arbeitszeit
#+BEGIN: clocktable :maxlevel 3 :scope file :block thisweek
Clock summary at [2014-12-22 Mon 16:34], for week 2014-W52.

| Headline     | Time   |
|--------------+--------|
| *Total time* | *0:00* |
#+END:

| Week     |      Time |  Overtime |
|----------+-----------+-----------|
| 2014-W20 |     10:32 |  01:32:00 |
| 2014-W21 |     09:08 |  00:08:00 |
| 2014-W22 |     12:55 |  03:55:00 |
| 2014-W23 |     10:49 |  01:49:00 |
| 2014-W24 |      7:41 | -01:19:00 |
| 2014-W25 |      8:01 | -00:59:00 |
| 2014-W26 |      5:21 | -03:39:00 |
| 2014-W27 |      5:43 | -03:17:00 |
| 2014-W28 |      4:33 | -04:27:00 |
| 2014-W29 |      0:23 | -08:37:00 |
| 2014-W30 |     11:18 |  02:18:00 |
| 2014-W31 |      8:48 | -00:12:00 |
| 2014-W32 |     11:48 |  02:48:00 |
| 2014-W33 |     11:04 |  02:04:00 |
| 2014-W34 |     15:04 |  06:04:00 |
| 2014-W35 |     11:23 |  02:23:00 |
| 2014-W37 |      6:00 | -03:00:00 |
| 2014-W38 |      8:09 | -00:51:00 |
| 2014-W39 |     12:13 |  03:13:00 |
| 2014-W40 |      5:00 | -04:00:00 |
| 2014-W41 |      9:02 |  00:02:00 |
| 2014-W42 |     13:08 |  04:08:00 |
| 2014-W43 |      9:00 |  00:00:00 |
| 2014-W44 |      9:17 |  00:17:00 |
| 2014-W45 |     11:24 |  02:24:00 |
| 2014-W46 |      9:12 |  00:12:00 |
| 2014-W47 |      9:03 |  00:03:00 |
| 2014-W48 |      8:21 | -00:39:00 |
| 2014-W49 |     10:58 |  01:58:00 |
| 2014-W50 |      7:12 | -01:48:00 |
| 2014-W51 |      4:00 | -05:00:00 |
|----------+-----------+-----------|
| Total    | 276:30:00 | -02:30:00 |
#+TBLFM: $3=$2-9*3600;T::@>$2=vsum(@2$2..@-1$2);T::@>$3=vsum(@2$3..@-1$3);T::
